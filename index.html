<!doctype html>
<html>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>
<title>MySQL1刷</title><link href='https://fonts.loli.net/css?family=Open+Sans:400italic,700italic,700,400&subset=latin,latin-ext' rel='stylesheet' type='text/css' /><style type='text/css'>html {overflow-x: initial !important;}:root { --bg-color:#ffffff; --text-color:#333333; --select-text-bg-color:#B5D6FC; --select-text-font-color:auto; --monospace:"Lucida Console",Consolas,"Courier",monospace; }
html { font-size: 14px; background-color: var(--bg-color); color: var(--text-color); font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; }
body { margin: 0px; padding: 0px; height: auto; bottom: 0px; top: 0px; left: 0px; right: 0px; font-size: 1rem; line-height: 1.42857; overflow-x: hidden; background: inherit; tab-size: 4; }
iframe { margin: auto; }
a.url { word-break: break-all; }
a:active, a:hover { outline: 0px; }
.in-text-selection, ::selection { text-shadow: none; background: var(--select-text-bg-color); color: var(--select-text-font-color); }
#write { margin: 0px auto; height: auto; width: inherit; word-break: normal; word-wrap: break-word; position: relative; white-space: normal; overflow-x: visible; padding-top: 40px; }
#write.first-line-indent p { text-indent: 2em; }
#write.first-line-indent li p, #write.first-line-indent p * { text-indent: 0px; }
#write.first-line-indent li { margin-left: 2em; }
.for-image #write { padding-left: 8px; padding-right: 8px; }
body.typora-export { padding-left: 30px; padding-right: 30px; }
.typora-export .footnote-line, .typora-export li, .typora-export p { white-space: pre-wrap; }
@media screen and (max-width: 500px) {
  body.typora-export { padding-left: 0px; padding-right: 0px; }
  #write { padding-left: 20px; padding-right: 20px; }
  .CodeMirror-sizer { margin-left: 0px !important; }
  .CodeMirror-gutters { display: none !important; }
}
#write li > figure:first-child { margin-top: -20px; }
#write ol, #write ul { position: relative; }
img { max-width: 100%; vertical-align: middle; }
button, input, select, textarea { color: inherit; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-size: inherit; line-height: inherit; font-family: inherit; }
input[type="checkbox"], input[type="radio"] { line-height: normal; padding: 0px; }
*, ::after, ::before { box-sizing: border-box; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p, #write pre { width: inherit; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p { position: relative; }
h1, h2, h3, h4, h5, h6 { break-after: avoid-page; break-inside: avoid; orphans: 2; }
p { orphans: 4; }
h1 { font-size: 2rem; }
h2 { font-size: 1.8rem; }
h3 { font-size: 1.6rem; }
h4 { font-size: 1.4rem; }
h5 { font-size: 1.2rem; }
h6 { font-size: 1rem; }
.md-math-block, .md-rawblock, h1, h2, h3, h4, h5, h6, p { margin-top: 1rem; margin-bottom: 1rem; }
.hidden { display: none; }
.md-blockmeta { color: rgb(204, 204, 204); font-weight: 700; font-style: italic; }
a { cursor: pointer; }
sup.md-footnote { padding: 2px 4px; background-color: rgba(238, 238, 238, 0.7); color: rgb(85, 85, 85); border-radius: 4px; cursor: pointer; }
sup.md-footnote a, sup.md-footnote a:hover { color: inherit; text-transform: inherit; text-decoration: inherit; }
#write input[type="checkbox"] { cursor: pointer; width: inherit; height: inherit; }
figure { overflow-x: auto; margin: 1.2em 0px; max-width: calc(100% + 16px); padding: 0px; }
figure > table { margin: 0px !important; }
tr { break-inside: avoid; break-after: auto; }
thead { display: table-header-group; }
table { border-collapse: collapse; border-spacing: 0px; width: 100%; overflow: auto; break-inside: auto; text-align: left; }
table.md-table td { min-width: 32px; }
.CodeMirror-gutters { border-right: 0px; background-color: inherit; }
.CodeMirror-linenumber { user-select: none; }
.CodeMirror { text-align: left; }
.CodeMirror-placeholder { opacity: 0.3; }
.CodeMirror pre { padding: 0px 4px; }
.CodeMirror-lines { padding: 0px; }
div.hr:focus { cursor: none; }
#write pre { white-space: pre-wrap; }
#write.fences-no-line-wrapping pre { white-space: pre; }
#write pre.ty-contain-cm { white-space: normal; }
.CodeMirror-gutters { margin-right: 4px; }
.md-fences { font-size: 0.9rem; display: block; break-inside: avoid; text-align: left; overflow: visible; white-space: pre; background: inherit; position: relative !important; }
.md-diagram-panel { width: 100%; margin-top: 10px; text-align: center; padding-top: 0px; padding-bottom: 8px; overflow-x: auto; }
#write .md-fences.mock-cm { white-space: pre-wrap; }
.md-fences.md-fences-with-lineno { padding-left: 0px; }
#write.fences-no-line-wrapping .md-fences.mock-cm { white-space: pre; overflow-x: auto; }
.md-fences.mock-cm.md-fences-with-lineno { padding-left: 8px; }
.CodeMirror-line, twitterwidget { break-inside: avoid; }
.footnotes { opacity: 0.8; font-size: 0.9rem; margin-top: 1em; margin-bottom: 1em; }
.footnotes + .footnotes { margin-top: 0px; }
.md-reset { margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: top; background: 0px 0px; text-decoration: none; text-shadow: none; float: none; position: static; width: auto; height: auto; white-space: nowrap; cursor: inherit; -webkit-tap-highlight-color: transparent; line-height: normal; font-weight: 400; text-align: left; box-sizing: content-box; direction: ltr; }
li div { padding-top: 0px; }
blockquote { margin: 1rem 0px; }
li .mathjax-block, li p { margin: 0.5rem 0px; }
li { margin: 0px; position: relative; }
blockquote > :last-child { margin-bottom: 0px; }
blockquote > :first-child, li > :first-child { margin-top: 0px; }
.footnotes-area { color: rgb(136, 136, 136); margin-top: 0.714rem; padding-bottom: 0.143rem; white-space: normal; }
#write .footnote-line { white-space: pre-wrap; }
@media print {
  body, html { border: 1px solid transparent; height: 99%; break-after: avoid; break-before: avoid; }
  #write { margin-top: 0px; padding-top: 0px; border-color: transparent !important; }
  .typora-export * { -webkit-print-color-adjust: exact; }
  html.blink-to-pdf { font-size: 13px; }
  .typora-export #write { padding-left: 32px; padding-right: 32px; padding-bottom: 0px; break-after: avoid; }
  .typora-export #write::after { height: 0px; }
  @page { margin: 20mm 0px; }
}
.footnote-line { margin-top: 0.714em; font-size: 0.7em; }
a img, img a { cursor: pointer; }
pre.md-meta-block { font-size: 0.8rem; min-height: 0.8rem; white-space: pre-wrap; background: rgb(204, 204, 204); display: block; overflow-x: hidden; }
p > .md-image:only-child:not(.md-img-error) img, p > img:only-child { display: block; margin: auto; }
p > .md-image:only-child { display: inline-block; width: 100%; }
#write .MathJax_Display { margin: 0.8em 0px 0px; }
.md-math-block { width: 100%; }
.md-math-block:not(:empty)::after { display: none; }
[contenteditable="true"]:active, [contenteditable="true"]:focus { outline: 0px; box-shadow: none; }
.md-task-list-item { position: relative; list-style-type: none; }
.task-list-item.md-task-list-item { padding-left: 0px; }
.md-task-list-item > input { position: absolute; top: 0px; left: 0px; margin-left: -1.2em; margin-top: calc(1em - 10px); border: none; }
.math { font-size: 1rem; }
.md-toc { min-height: 3.58rem; position: relative; font-size: 0.9rem; border-radius: 10px; }
.md-toc-content { position: relative; margin-left: 0px; }
.md-toc-content::after, .md-toc::after { display: none; }
.md-toc-item { display: block; color: rgb(65, 131, 196); }
.md-toc-item a { text-decoration: none; }
.md-toc-inner:hover { text-decoration: underline; }
.md-toc-inner { display: inline-block; cursor: pointer; }
.md-toc-h1 .md-toc-inner { margin-left: 0px; font-weight: 700; }
.md-toc-h2 .md-toc-inner { margin-left: 2em; }
.md-toc-h3 .md-toc-inner { margin-left: 4em; }
.md-toc-h4 .md-toc-inner { margin-left: 6em; }
.md-toc-h5 .md-toc-inner { margin-left: 8em; }
.md-toc-h6 .md-toc-inner { margin-left: 10em; }
@media screen and (max-width: 48em) {
  .md-toc-h3 .md-toc-inner { margin-left: 3.5em; }
  .md-toc-h4 .md-toc-inner { margin-left: 5em; }
  .md-toc-h5 .md-toc-inner { margin-left: 6.5em; }
  .md-toc-h6 .md-toc-inner { margin-left: 8em; }
}
a.md-toc-inner { font-size: inherit; font-style: inherit; font-weight: inherit; line-height: inherit; }
.footnote-line a:not(.reversefootnote) { color: inherit; }
.md-attr { display: none; }
.md-fn-count::after { content: "."; }
code, pre, samp, tt { font-family: var(--monospace); }
kbd { margin: 0px 0.1em; padding: 0.1em 0.6em; font-size: 0.8em; color: rgb(36, 39, 41); background: rgb(255, 255, 255); border: 1px solid rgb(173, 179, 185); border-radius: 3px; box-shadow: rgba(12, 13, 14, 0.2) 0px 1px 0px, rgb(255, 255, 255) 0px 0px 0px 2px inset; white-space: nowrap; vertical-align: middle; }
.md-comment { color: rgb(162, 127, 3); opacity: 0.8; font-family: var(--monospace); }
code { text-align: left; vertical-align: initial; }
a.md-print-anchor { white-space: pre !important; border-width: initial !important; border-style: none !important; border-color: initial !important; display: inline-block !important; position: absolute !important; width: 1px !important; right: 0px !important; outline: 0px !important; background: 0px 0px !important; text-decoration: initial !important; text-shadow: initial !important; }
.md-inline-math .MathJax_SVG .noError { display: none !important; }
.html-for-mac .inline-math-svg .MathJax_SVG { vertical-align: 0.2px; }
.md-math-block .MathJax_SVG_Display { text-align: center; margin: 0px; position: relative; text-indent: 0px; max-width: none; max-height: none; min-height: 0px; min-width: 100%; width: auto; overflow-y: hidden; display: block !important; }
.MathJax_SVG_Display, .md-inline-math .MathJax_SVG_Display { width: auto; margin: inherit; display: inline-block !important; }
.MathJax_SVG .MJX-monospace { font-family: var(--monospace); }
.MathJax_SVG .MJX-sans-serif { font-family: sans-serif; }
.MathJax_SVG { display: inline; font-style: normal; font-weight: 400; line-height: normal; zoom: 90%; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; }
.MathJax_SVG * { transition: none; }
.MathJax_SVG_Display svg { vertical-align: middle !important; margin-bottom: 0px !important; }
.os-windows.monocolor-emoji .md-emoji { font-family: "Segoe UI Symbol", sans-serif; }
.md-diagram-panel > svg { max-width: 100%; }
[lang="mermaid"] svg, [lang="flow"] svg { max-width: 100%; }
[lang="mermaid"] .node text { font-size: 1rem; }
table tr th { border-bottom: 0px; }
video { max-width: 100%; display: block; margin: 0px auto; }
iframe { max-width: 100%; width: 100%; border: none; }
.highlight td, .highlight tr { border: 0px; }


.CodeMirror { height: auto; }
.CodeMirror.cm-s-inner { background: inherit; }
.CodeMirror-scroll { overflow-y: hidden; overflow-x: auto; z-index: 3; }
.CodeMirror-gutter-filler, .CodeMirror-scrollbar-filler { background-color: rgb(255, 255, 255); }
.CodeMirror-gutters { border-right: 1px solid rgb(221, 221, 221); background: inherit; white-space: nowrap; }
.CodeMirror-linenumber { padding: 0px 3px 0px 5px; text-align: right; color: rgb(153, 153, 153); }
.cm-s-inner .cm-keyword { color: rgb(119, 0, 136); }
.cm-s-inner .cm-atom, .cm-s-inner.cm-atom { color: rgb(34, 17, 153); }
.cm-s-inner .cm-number { color: rgb(17, 102, 68); }
.cm-s-inner .cm-def { color: rgb(0, 0, 255); }
.cm-s-inner .cm-variable { color: rgb(0, 0, 0); }
.cm-s-inner .cm-variable-2 { color: rgb(0, 85, 170); }
.cm-s-inner .cm-variable-3 { color: rgb(0, 136, 85); }
.cm-s-inner .cm-string { color: rgb(170, 17, 17); }
.cm-s-inner .cm-property { color: rgb(0, 0, 0); }
.cm-s-inner .cm-operator { color: rgb(152, 26, 26); }
.cm-s-inner .cm-comment, .cm-s-inner.cm-comment { color: rgb(170, 85, 0); }
.cm-s-inner .cm-string-2 { color: rgb(255, 85, 0); }
.cm-s-inner .cm-meta { color: rgb(85, 85, 85); }
.cm-s-inner .cm-qualifier { color: rgb(85, 85, 85); }
.cm-s-inner .cm-builtin { color: rgb(51, 0, 170); }
.cm-s-inner .cm-bracket { color: rgb(153, 153, 119); }
.cm-s-inner .cm-tag { color: rgb(17, 119, 0); }
.cm-s-inner .cm-attribute { color: rgb(0, 0, 204); }
.cm-s-inner .cm-header, .cm-s-inner.cm-header { color: rgb(0, 0, 255); }
.cm-s-inner .cm-quote, .cm-s-inner.cm-quote { color: rgb(0, 153, 0); }
.cm-s-inner .cm-hr, .cm-s-inner.cm-hr { color: rgb(153, 153, 153); }
.cm-s-inner .cm-link, .cm-s-inner.cm-link { color: rgb(0, 0, 204); }
.cm-negative { color: rgb(221, 68, 68); }
.cm-positive { color: rgb(34, 153, 34); }
.cm-header, .cm-strong { font-weight: 700; }
.cm-del { text-decoration: line-through; }
.cm-em { font-style: italic; }
.cm-link { text-decoration: underline; }
.cm-error { color: red; }
.cm-invalidchar { color: red; }
.cm-constant { color: rgb(38, 139, 210); }
.cm-defined { color: rgb(181, 137, 0); }
div.CodeMirror span.CodeMirror-matchingbracket { color: rgb(0, 255, 0); }
div.CodeMirror span.CodeMirror-nonmatchingbracket { color: rgb(255, 34, 34); }
.cm-s-inner .CodeMirror-activeline-background { background: inherit; }
.CodeMirror { position: relative; overflow: hidden; }
.CodeMirror-scroll { height: 100%; outline: 0px; position: relative; box-sizing: content-box; background: inherit; }
.CodeMirror-sizer { position: relative; }
.CodeMirror-gutter-filler, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-vscrollbar { position: absolute; z-index: 6; display: none; }
.CodeMirror-vscrollbar { right: 0px; top: 0px; overflow: hidden; }
.CodeMirror-hscrollbar { bottom: 0px; left: 0px; overflow: hidden; }
.CodeMirror-scrollbar-filler { right: 0px; bottom: 0px; }
.CodeMirror-gutter-filler { left: 0px; bottom: 0px; }
.CodeMirror-gutters { position: absolute; left: 0px; top: 0px; padding-bottom: 30px; z-index: 3; }
.CodeMirror-gutter { white-space: normal; height: 100%; box-sizing: content-box; padding-bottom: 30px; margin-bottom: -32px; display: inline-block; }
.CodeMirror-gutter-wrapper { position: absolute; z-index: 4; background: 0px 0px !important; border: none !important; }
.CodeMirror-gutter-background { position: absolute; top: 0px; bottom: 0px; z-index: 4; }
.CodeMirror-gutter-elt { position: absolute; cursor: default; z-index: 4; }
.CodeMirror-lines { cursor: text; }
.CodeMirror pre { border-radius: 0px; border-width: 0px; background: 0px 0px; font-family: inherit; font-size: inherit; margin: 0px; white-space: pre; word-wrap: normal; color: inherit; z-index: 2; position: relative; overflow: visible; }
.CodeMirror-wrap pre { word-wrap: break-word; white-space: pre-wrap; word-break: normal; }
.CodeMirror-code pre { border-right: 30px solid transparent; width: fit-content; }
.CodeMirror-wrap .CodeMirror-code pre { border-right: none; width: auto; }
.CodeMirror-linebackground { position: absolute; left: 0px; right: 0px; top: 0px; bottom: 0px; z-index: 0; }
.CodeMirror-linewidget { position: relative; z-index: 2; overflow: auto; }
.CodeMirror-wrap .CodeMirror-scroll { overflow-x: hidden; }
.CodeMirror-measure { position: absolute; width: 100%; height: 0px; overflow: hidden; visibility: hidden; }
.CodeMirror-measure pre { position: static; }
.CodeMirror div.CodeMirror-cursor { position: absolute; visibility: hidden; border-right: none; width: 0px; }
.CodeMirror div.CodeMirror-cursor { visibility: hidden; }
.CodeMirror-focused div.CodeMirror-cursor { visibility: inherit; }
.cm-searching { background: rgba(255, 255, 0, 0.4); }
@media print {
  .CodeMirror div.CodeMirror-cursor { visibility: hidden; }
}


:root { --side-bar-bg-color: #fafafa; --control-text-color: #777; }
html { font-size: 16px; -webkit-font-smoothing: antialiased; }
body { font-family: "Open Sans", "Clear Sans", "Helvetica Neue", Helvetica, Arial, "Segoe UI Emoji", sans-serif; color: rgb(0, 64, 80); line-height: 1.6; }
#write { max-width: 860px; margin: 0px auto; padding: 30px 30px 100px; }
@media only screen and (min-width: 1400px) {
  #write { max-width: 1024px; }
}
@media only screen and (min-width: 1800px) {
  #write { max-width: 1200px; }
}
#write > ul:first-child, #write > ol:first-child { margin-top: 30px; }
a { color: rgb(65, 131, 196); }
h1, h2, h3, h4, h5, h6 { position: relative; margin-top: 1rem; margin-bottom: 1rem; font-weight: bold; line-height: 1.4; cursor: text; }
h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor { text-decoration: none; }
h1 tt, h1 code { font-size: inherit; }
h2 tt, h2 code { font-size: inherit; }
h3 tt, h3 code { font-size: inherit; }
h4 tt, h4 code { font-size: inherit; }
h5 tt, h5 code { font-size: inherit; }
h6 tt, h6 code { font-size: inherit; }
h1 { font-size: 2.25em; line-height: 1.2; border-bottom: 1px solid rgb(238, 238, 238); }
h2 { font-size: 1.75em; line-height: 1.225; border-bottom: 1px solid rgb(238, 238, 238); }
h3 { font-size: 1.5em; line-height: 1.43; }
h4 { font-size: 1.25em; }
h5 { font-size: 1em; }
h6 { font-size: 1em; color: rgb(119, 119, 119); }
p, blockquote, ul, ol, dl, table { margin: 0.8em 0px; }
li > ol, li > ul { margin: 0px; }
hr { height: 2px; padding: 0px; margin: 16px 0px; background-color: rgb(231, 231, 231); border: 0px none; overflow: hidden; box-sizing: content-box; }
li p.first { display: inline-block; }
ul, ol { padding-left: 30px; }
ul:first-child, ol:first-child { margin-top: 0px; }
ul:last-child, ol:last-child { margin-bottom: 0px; }
blockquote { border-left: 5px solid rgb(66, 185, 131); padding: 8px 15px; color: rgb(33, 93, 66); background-color: rgb(243, 245, 247); }
blockquote blockquote { padding-right: 0px; }
table { padding: 0px; word-break: initial; }
table tr { border: 1px solid rgb(223, 226, 229); margin: 0px; padding: 0px; }
table tr:nth-child(2n), thead { background-color: rgb(248, 248, 248); }
table th { font-weight: bold; border-width: 1px 1px 0px; border-top-style: solid; border-right-style: solid; border-left-style: solid; border-top-color: rgb(223, 226, 229); border-right-color: rgb(223, 226, 229); border-left-color: rgb(223, 226, 229); border-image: initial; border-bottom-style: initial; border-bottom-color: initial; margin: 0px; padding: 6px 13px; }
table td { border: 1px solid rgb(223, 226, 229); margin: 0px; padding: 6px 13px; }
table th:first-child, table td:first-child { margin-top: 0px; }
table th:last-child, table td:last-child { margin-bottom: 0px; }
.CodeMirror-lines { padding-left: 4px; }
.code-tooltip { box-shadow: rgba(0, 28, 36, 0.3) 0px 1px 1px 0px; border-top: 1px solid rgb(238, 242, 242); }
.md-fences, code, tt { border: 1px solid rgb(231, 234, 237); background-color: rgb(248, 248, 248); border-radius: 3px; padding: 2px 4px 0px; font-size: 0.9em; }
code { background-color: rgb(243, 244, 244); padding: 2px; color: rgb(209, 37, 115); }
.md-fences { margin-bottom: 15px; margin-top: 15px; padding-top: 8px; padding-bottom: 6px; }
.md-task-list-item > input { margin-left: -1.3em; }
@media print {
  html { font-size: 13px; }
  table, pre { break-inside: avoid; }
  pre { word-wrap: break-word; }
}
.md-fences { background-color: rgb(248, 248, 248); }
#write pre.md-meta-block { padding: 1rem; font-size: 85%; line-height: 1.45; background-color: rgb(247, 247, 247); border: 0px; border-radius: 3px; color: rgb(119, 119, 119); margin-top: 0px !important; }
.mathjax-block > .code-tooltip { bottom: 0.375rem; }
.md-mathjax-midline { background: rgb(250, 250, 250); }
#write > h3.md-focus::before { left: -1.5625rem; top: 0.375rem; }
#write > h4.md-focus::before { left: -1.5625rem; top: 0.285714rem; }
#write > h5.md-focus::before { left: -1.5625rem; top: 0.285714rem; }
#write > h6.md-focus::before { left: -1.5625rem; top: 0.285714rem; }
.md-image > .md-meta { border-radius: 3px; padding: 2px 0px 0px 4px; font-size: 0.9em; color: inherit; }
.md-tag { color: rgb(167, 167, 167); opacity: 1; }
.md-toc { margin-top: 20px; padding-bottom: 20px; }
.sidebar-tabs { border-bottom: none; }
#typora-quick-open { border: 1px solid rgb(221, 221, 221); background-color: rgb(248, 248, 248); }
#typora-quick-open-item { background-color: rgb(250, 250, 250); border-color: rgb(254, 254, 254) rgb(229, 229, 229) rgb(229, 229, 229) rgb(238, 238, 238); border-style: solid; border-width: 1px; }
.on-focus-mode blockquote { border-left-color: rgba(85, 85, 85, 0.12); }
header, .context-menu, .megamenu-content, footer { font-family: "Segoe UI", Arial, sans-serif; }
.file-node-content:hover .file-node-icon, .file-node-content:hover .file-node-open-state { visibility: visible; }
.mac-seamless-mode #typora-sidebar { background-color: var(--side-bar-bg-color); }
.md-lang { color: rgb(180, 101, 77); }
#md-notification .btn { border: 0px; }
.dropdown-menu .divider { border-color: rgb(229, 229, 229); opacity: 0.4; }
.ty-preferences .window-content { background-color: rgb(250, 250, 250); }
.ty-preferences .nav-group-item.active { color: white; background: rgb(153, 153, 153); }
.menu-item-container a.menu-style-btn { background-color: rgb(245, 248, 250); background-image: linear-gradient(rgba(255, 255, 255, 0.8), rgba(255, 255, 255, 0)); }
#write mark { background: transparent; color: rgb(216, 105, 105); font-weight: bold; }
p .md-image:only-child { width: auto; text-align: left; }


.cm-s-inner { background-color: rgb(38, 50, 56); color: rgb(233, 237, 237); }
.cm-s-inner .CodeMirror-gutters { background: rgb(38, 50, 56); color: rgb(83, 127, 126); border: none; }
.cm-s-inner .CodeMirror-guttermarker, .cm-s-inner .CodeMirror-guttermarker-subtle, .cm-s-inner .CodeMirror-linenumber { color: rgb(83, 127, 126); }
.cm-s-inner .CodeMirror-cursor { border-left: 1px solid rgb(248, 248, 240); }
.cm-s-inner div.CodeMirror-selected { background: rgba(255, 255, 255, 0.15); }
.cm-s-inner.CodeMirror-focused div.CodeMirror-selected { background: rgba(255, 255, 255, 0.1); }
.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line > span::selection, .cm-s-inner .CodeMirror-line > span > span::selection { background: rgba(255, 255, 255, 0.1); }
.cm-s-inner .CodeMirror-activeline-background { background: rgba(0, 0, 0, 0); }
.cm-s-inner .cm-keyword { color: rgb(199, 146, 234); }
.cm-s-inner .cm-operator { color: rgb(233, 237, 237); }
.cm-s-inner .cm-variable-2 { color: rgb(128, 203, 196); }
.cm-s-inner .cm-variable-3 { color: rgb(158, 255, 255); }
.cm-s-inner .cm-builtin { color: rgb(222, 203, 107); }
.cm-s-inner .cm-atom { color: rgb(247, 118, 105); }
.cm-s-inner .cm-number { color: rgb(247, 118, 105); }
.cm-s-inner .cm-def { color: rgb(233, 237, 237); }
.cm-s-inner .cm-string { color: rgb(195, 232, 141); }
.cm-s-inner .cm-string-2 { color: rgb(128, 203, 196); }
.cm-s-inner .cm-comment { color: rgb(84, 110, 122); }
.cm-s-inner .cm-variable { color: rgb(158, 255, 255); }
.cm-s-inner .cm-tag { color: rgb(128, 203, 196); }
.cm-s-inner .cm-meta { color: rgb(128, 203, 196); }
.cm-s-inner .cm-attribute { color: rgb(255, 203, 107); }
.cm-s-inner .cm-property { color: rgb(128, 203, 174); }
.cm-s-inner .cm-qualifier { color: rgb(222, 203, 107); }
.cm-s-inner .cm-variable-3 { color: rgb(222, 203, 107); }
.cm-s-inner .cm-tag { color: rgb(255, 83, 112); }
.cm-s-inner .cm-error { color: rgb(255, 255, 255); background-color: rgb(236, 95, 103); }
.cm-s-inner .CodeMirror-matchingbracket { text-decoration: underline; color: white !important; }
.md-fences { background-color: rgb(38, 50, 56); color: rgb(233, 237, 237); border: none; }
.md-fences .code-tooltip { background-color: rgb(38, 50, 56); }




</style>
</head>
<body class='typora-export os-windows' >
<div  id='write'  class = 'is-node first-line-indent'><p>﻿@<a href='%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86'>TOC</a></p><div class='md-toc' mdtype='toc'><p class="md-toc-content"><span class="md-toc-item md-toc-h1" data-ref="n4"><a class="md-toc-inner" href="#header-n4">数据库-DDL</a></span><span class="md-toc-item md-toc-h2" data-ref="n7"><a class="md-toc-inner" href="#header-n7">01. 查看所有数据库</a></span><span class="md-toc-item md-toc-h2" data-ref="n10"><a class="md-toc-inner" href="#header-n10">02. 创建数据库</a></span><span class="md-toc-item md-toc-h2" data-ref="n13"><a class="md-toc-inner" href="#header-n13">03. 选择使用数据库</a></span><span class="md-toc-item md-toc-h2" data-ref="n16"><a class="md-toc-inner" href="#header-n16">04.  删除数据库</a></span><span class="md-toc-item md-toc-h2" data-ref="n19"><a class="md-toc-inner" href="#header-n19">05. 修改数据库编码</a></span><span class="md-toc-item md-toc-h2" data-ref="n22"><a class="md-toc-inner" href="#header-n22">06. 数据库中创建表</a></span><span class="md-toc-item md-toc-h2" data-ref="n25"><a class="md-toc-inner" href="#header-n25">07. 数值类型</a></span><span class="md-toc-item md-toc-h2" data-ref="n28"><a class="md-toc-inner" href="#header-n28">08. 字符串类型</a></span><span class="md-toc-item md-toc-h2" data-ref="n31"><a class="md-toc-inner" href="#header-n31">09. 日期类型</a></span><span class="md-toc-item md-toc-h2" data-ref="n34"><a class="md-toc-inner" href="#header-n34">10. 查看当前数据库所有的表</a></span><span class="md-toc-item md-toc-h2" data-ref="n37"><a class="md-toc-inner" href="#header-n37">11. 查看指定表</a></span><span class="md-toc-item md-toc-h2" data-ref="n40"><a class="md-toc-inner" href="#header-n40">12. 查看表结构</a></span><span class="md-toc-item md-toc-h2" data-ref="n43"><a class="md-toc-inner" href="#header-n43">13. 删除指定表</a></span><span class="md-toc-item md-toc-h2" data-ref="n46"><a class="md-toc-inner" href="#header-n46">14. 表中添加一列</a></span><span class="md-toc-item md-toc-h2" data-ref="n49"><a class="md-toc-inner" href="#header-n49">15. 修改列名和类型</a></span><span class="md-toc-item md-toc-h2" data-ref="n52"><a class="md-toc-inner" href="#header-n52">16. 删除列</a></span><span class="md-toc-item md-toc-h2" data-ref="n55"><a class="md-toc-inner" href="#header-n55">17. 修改表名</a></span><span class="md-toc-item md-toc-h2" data-ref="n58"><a class="md-toc-inner" href="#header-n58">18. 表中数据插入</a></span><span class="md-toc-item md-toc-h2" data-ref="n62"><a class="md-toc-inner" href="#header-n62">19. 表中数据修改</a></span><span class="md-toc-item md-toc-h2" data-ref="n66"><a class="md-toc-inner" href="#header-n66">20. 表中数据删除</a></span><span class="md-toc-item md-toc-h2" data-ref="n70"><a class="md-toc-inner" href="#header-n70">21. 删除表中所有数据</a></span><span class="md-toc-item md-toc-h2" data-ref="n73"><a class="md-toc-inner" href="#header-n73">22. 清空表数据</a></span><span class="md-toc-item md-toc-h2" data-ref="n78"><a class="md-toc-inner" href="#header-n78">23. SQL约束</a></span><span class="md-toc-item md-toc-h2" data-ref="n81"><a class="md-toc-inner" href="#header-n81">24. 主键约束</a></span><span class="md-toc-item md-toc-h2" data-ref="n84"><a class="md-toc-inner" href="#header-n84">25. 添加单列主键</a></span><span class="md-toc-item md-toc-h2" data-ref="n104"><a class="md-toc-inner" href="#header-n104">26. 添加联合主键</a></span><span class="md-toc-item md-toc-h2" data-ref="n113"><a class="md-toc-inner" href="#header-n113">27. 通过修改表结构添加主键</a></span><span class="md-toc-item md-toc-h2" data-ref="n117"><a class="md-toc-inner" href="#header-n117">28. 删除主键约束</a></span><span class="md-toc-item md-toc-h2" data-ref="n123"><a class="md-toc-inner" href="#header-n123">29. 自增长约束</a></span><span class="md-toc-item md-toc-h2" data-ref="n146"><a class="md-toc-inner" href="#header-n146">30. 指定自增字段初始值</a></span><span class="md-toc-item md-toc-h2" data-ref="n166"><a class="md-toc-inner" href="#header-n166">31. 取消自增长</a></span><span class="md-toc-item md-toc-h2" data-ref="n174"><a class="md-toc-inner" href="#header-n174">32. 非空约束</a></span><span class="md-toc-item md-toc-h2" data-ref="n189"><a class="md-toc-inner" href="#header-n189">33. 删除非空约束</a></span><span class="md-toc-item md-toc-h2" data-ref="n194"><a class="md-toc-inner" href="#header-n194">34. 唯一约束</a></span><span class="md-toc-item md-toc-h2" data-ref="n207"><a class="md-toc-inner" href="#header-n207">35. 删除唯一约束</a></span><span class="md-toc-item md-toc-h2" data-ref="n212"><a class="md-toc-inner" href="#header-n212">36. 默认约束</a></span><span class="md-toc-item md-toc-h2" data-ref="n227"><a class="md-toc-inner" href="#header-n227">37. 删除默认约束</a></span><span class="md-toc-item md-toc-h2" data-ref="n231"><a class="md-toc-inner" href="#header-n231">38. zerofill</a></span><span class="md-toc-item md-toc-h1" data-ref="n248"><a class="md-toc-inner" href="#header-n248">数据库-DQL</a></span><span class="md-toc-item md-toc-h2" data-ref="n249"><a class="md-toc-inner" href="#header-n249">01. 基本查询</a></span><span class="md-toc-item md-toc-h2" data-ref="n256"><a class="md-toc-inner" href="#header-n256">02. 简单查询</a></span><span class="md-toc-item md-toc-h2" data-ref="n258"><a class="md-toc-inner" href="#header-n258">03. 别名查询</a></span><span class="md-toc-item md-toc-h2" data-ref="n262"><a class="md-toc-inner" href="#header-n262">04. distinct去重</a></span><span class="md-toc-item md-toc-h2" data-ref="n265"><a class="md-toc-inner" href="#header-n265">05. 运算查询</a></span><span class="md-toc-item md-toc-h2" data-ref="n270"><a class="md-toc-inner" href="#header-n270">06. 算术运算符</a></span><span class="md-toc-item md-toc-h2" data-ref="n274"><a class="md-toc-inner" href="#header-n274">07. 比较运算符</a></span><span class="md-toc-item md-toc-h2" data-ref="n276"><a class="md-toc-inner" href="#header-n276">08. 逻辑运算符</a></span><span class="md-toc-item md-toc-h2" data-ref="n278"><a class="md-toc-inner" href="#header-n278">09. 位运算符</a></span><span class="md-toc-item md-toc-h2" data-ref="n282"><a class="md-toc-inner" href="#header-n282">10. 条件查询</a></span><span class="md-toc-item md-toc-h2" data-ref="n286"><a class="md-toc-inner" href="#header-n286">11. LEAST GREATEST</a></span><span class="md-toc-item md-toc-h2" data-ref="n295"><a class="md-toc-inner" href="#header-n295">12. 排序查询</a></span><span class="md-toc-item md-toc-h2" data-ref="n305"><a class="md-toc-inner" href="#header-n305">13. 聚合查询</a></span><span class="md-toc-item md-toc-h2" data-ref="n315"><a class="md-toc-inner" href="#header-n315">14. 聚合查询NULL的处理</a></span><span class="md-toc-item md-toc-h2" data-ref="n321"><a class="md-toc-inner" href="#header-n321">15. 分组查询 </a></span><span class="md-toc-item md-toc-h2" data-ref="n331"><a class="md-toc-inner" href="#header-n331">16. having条件筛选</a></span><span class="md-toc-item md-toc-h2" data-ref="n345"><a class="md-toc-inner" href="#header-n345">17. 分页查询</a></span><span class="md-toc-item md-toc-h2" data-ref="n357"><a class="md-toc-inner" href="#header-n357">18. INSERT INTO SELECT</a></span><span class="md-toc-item md-toc-h2" data-ref="n365"><a class="md-toc-inner" href="#header-n365">19. SELECT INTO FROM</a></span><span class="md-toc-item md-toc-h2" data-ref="n376"><a class="md-toc-inner" href="#header-n376">20. 正则表达式</a></span><span class="md-toc-item md-toc-h2" data-ref="n393"><a class="md-toc-inner" href="#header-n393">21. 多表操作</a></span><span class="md-toc-item md-toc-h2" data-ref="n412"><a class="md-toc-inner" href="#header-n412">22. 外键约束:一对多关系</a></span><span class="md-toc-item md-toc-h2" data-ref="n444"><a class="md-toc-inner" href="#header-n444">23. 外键约束下的数据操作</a></span><span class="md-toc-item md-toc-h2" data-ref="n449"><a class="md-toc-inner" href="#header-n449">24. 外键约束下的数据删除</a></span><span class="md-toc-item md-toc-h2" data-ref="n452"><a class="md-toc-inner" href="#header-n452">25. 删除外键约束</a></span><span class="md-toc-item md-toc-h2" data-ref="n458"><a class="md-toc-inner" href="#header-n458">26. 外键约束:多对多关系</a></span><span class="md-toc-item md-toc-h2" data-ref="n465"><a class="md-toc-inner" href="#header-n465">27. 多表联合查询</a></span><span class="md-toc-item md-toc-h2" data-ref="n487"><a class="md-toc-inner" href="#header-n487">28. 交叉连接查询</a></span><span class="md-toc-item md-toc-h2" data-ref="n506"><a class="md-toc-inner" href="#header-n506">29. 内连接查询</a></span><span class="md-toc-item md-toc-h2" data-ref="n516"><a class="md-toc-inner" href="#header-n516">30. 外连接查询</a></span><span class="md-toc-item md-toc-h2" data-ref="n529"><a class="md-toc-inner" href="#header-n529">31. 子查询</a></span><span class="md-toc-item md-toc-h2" data-ref="n547"><a class="md-toc-inner" href="#header-n547">32. 子查询关键字</a></span><span class="md-toc-item md-toc-h2" data-ref="n610"><a class="md-toc-inner" href="#header-n610">33. 自关联查询</a></span><span class="md-toc-item md-toc-h1" data-ref="n624"><a class="md-toc-inner" href="#header-n624">COMMENT的使用介绍</a></span><span class="md-toc-item md-toc-h2" data-ref="n629"><a class="md-toc-inner" href="#header-n629">1. 创建表时为字段添加注释</a></span><span class="md-toc-item md-toc-h2" data-ref="n632"><a class="md-toc-inner" href="#header-n632">2. 创建表后为字段添加注释</a></span><span class="md-toc-item md-toc-h2" data-ref="n635"><a class="md-toc-inner" href="#header-n635">3. 查看表中所有字段的注释</a></span><span class="md-toc-item md-toc-h2" data-ref="n648"><a class="md-toc-inner" href="#header-n648">4. 创建表时为表添加注释</a></span><span class="md-toc-item md-toc-h2" data-ref="n651"><a class="md-toc-inner" href="#header-n651">5. 创建表后为表添加注释</a></span><span class="md-toc-item md-toc-h2" data-ref="n654"><a class="md-toc-inner" href="#header-n654">6. 查看表注释</a></span><span class="md-toc-item md-toc-h1" data-ref="n669"><a class="md-toc-inner" href="#header-n669">视图</a></span><span class="md-toc-item md-toc-h2" data-ref="n670"><a class="md-toc-inner" href="#header-n670">1. 视图</a></span><span class="md-toc-item md-toc-h2" data-ref="n675"><a class="md-toc-inner" href="#header-n675">2. 视图创建</a></span><span class="md-toc-item md-toc-h2" data-ref="n679"><a class="md-toc-inner" href="#header-n679">3. 修改视图</a></span><span class="md-toc-item md-toc-h2" data-ref="n687"><a class="md-toc-inner" href="#header-n687">4. 视图更新</a></span><span class="md-toc-item md-toc-h2" data-ref="n690"><a class="md-toc-inner" href="#header-n690">5. 重命名/删除视图</a></span><span class="md-toc-item md-toc-h1" data-ref="n695"><a class="md-toc-inner" href="#header-n695">函数</a></span><span class="md-toc-item md-toc-h2" data-ref="n696"><a class="md-toc-inner" href="#header-n696">1. 聚合函数</a></span><span class="md-toc-item md-toc-h2" data-ref="n702"><a class="md-toc-inner" href="#header-n702">2. 数学函数</a></span><span class="md-toc-item md-toc-h2" data-ref="n705"><a class="md-toc-inner" href="#header-n705">3. 字符串函数</a></span><span class="md-toc-item md-toc-h2" data-ref="n708"><a class="md-toc-inner" href="#header-n708">4. 日期函数</a></span><span class="md-toc-item md-toc-h2" data-ref="n729"><a class="md-toc-inner" href="#header-n729">5. 控制流函数</a></span><span class="md-toc-item md-toc-h2" data-ref="n736"><a class="md-toc-inner" href="#header-n736">6. 窗口函数</a></span><span class="md-toc-item md-toc-h1" data-ref="n792"><a class="md-toc-inner" href="#header-n792">存储过程，触发器，索引，存储引擎</a></span><span class="md-toc-item md-toc-h2" data-ref="n793"><a class="md-toc-inner" href="#header-n793">1. 变量定义</a></span><span class="md-toc-item md-toc-h2" data-ref="n872"><a class="md-toc-inner" href="#header-n872">2. 流程控制</a></span><span class="md-toc-item md-toc-h2" data-ref="n918"><a class="md-toc-inner" href="#header-n918">3. 游标</a></span><span class="md-toc-item md-toc-h2" data-ref="n936"><a class="md-toc-inner" href="#header-n936">4. 存储函数</a></span><span class="md-toc-item md-toc-h2" data-ref="n963"><a class="md-toc-inner" href="#header-n963">5. 触发器</a></span><span class="md-toc-item md-toc-h2" data-ref="n1011"><a class="md-toc-inner" href="#header-n1011">6. 索引</a></span><span class="md-toc-item md-toc-h2" data-ref="n1096"><a class="md-toc-inner" href="#header-n1096">7. 存储引擎</a></span><span class="md-toc-item md-toc-h1" data-ref="n1122"><a class="md-toc-inner" href="#header-n1122">事务，锁机制，日志，MySQL优化</a></span><span class="md-toc-item md-toc-h2" data-ref="n1123"><a class="md-toc-inner" href="#header-n1123">1. 事务</a></span><span class="md-toc-item md-toc-h2" data-ref="n1154"><a class="md-toc-inner" href="#header-n1154">2. 锁机制</a></span><span class="md-toc-item md-toc-h2" data-ref="n1217"><a class="md-toc-inner" href="#header-n1217">3. 日志</a></span><span class="md-toc-item md-toc-h2" data-ref="n1281"><a class="md-toc-inner" href="#header-n1281">4. 优化</a></span></p></div><p>&nbsp;</p><h1><a name='header-n4' class='md-header-anchor '></a>数据库-DDL</h1><hr /><p>&nbsp;</p><h2><a name='header-n7' class='md-header-anchor '></a>01. 查看所有数据库</h2><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="sql"><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="sql"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8.16406px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment">-- 查看所有数据库</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">SHOW DATABASES;</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 45px;"></div><div class="CodeMirror-gutters" style="display: none; height: 45px;"></div></div></div></pre><hr /><h2><a name='header-n10' class='md-header-anchor '></a>02. 创建数据库</h2><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="sql"><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="sql"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8.16406px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment">-- 创建数据库</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">CREATE</span> DATABASE IF <span class="cm-keyword">NOT</span> EXISTS mydb;</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 45px;"></div><div class="CodeMirror-gutters" style="display: none; height: 45px;"></div></div></div></pre><hr /><h2><a name='header-n13' class='md-header-anchor '></a>03. 选择使用数据库</h2><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="sql"><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="sql"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8.16406px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment">-- 选择使用哪一个数据库</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">USE mydb;</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 45px;"></div><div class="CodeMirror-gutters" style="display: none; height: 45px;"></div></div></div></pre><hr /><h2><a name='header-n16' class='md-header-anchor '></a>04.  删除数据库</h2><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="sql"><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="sql"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8.16406px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment">-- 删除数据库</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">DROP</span> DATABASE mydb1;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">DROP</span> DATABASE if EXISTS mydb2;</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 68px;"></div><div class="CodeMirror-gutters" style="display: none; height: 68px;"></div></div></div></pre><hr /><h2><a name='header-n19' class='md-header-anchor '></a>05. 修改数据库编码</h2><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="sql"><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="sql"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8.16406px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment">-- 修改数据库编码</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">ALTER</span> DATABASE mydb_1 CHARACTER <span class="cm-keyword">SET</span> utf8;</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 45px;"></div><div class="CodeMirror-gutters" style="display: none; height: 45px;"></div></div></div></pre><hr /><h2><a name='header-n22' class='md-header-anchor '></a>06. 数据库中创建表</h2><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="sql"><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="sql"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8.16406px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><span><span>​</span>x</span></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment">-- 选择mydb</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">USE mydb;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment">-- 创建表</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">CREATE</span> <span class="cm-keyword">TABLE</span> if <span class="cm-keyword">NOT</span> EXISTS student(</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span>sid <span class="cm-builtin">int</span> <span class="cm-builtin">unsigned</span>,<span class="cm-tab" role="presentation" cm-text="	">   </span># 无符号整型</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span>name <span class="cm-builtin">VARCHAR</span>(<span class="cm-number">20</span>),</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span>gender <span class="cm-builtin">VARCHAR</span>(<span class="cm-number">2</span>),</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span>age <span class="cm-builtin">INT</span>,</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span>birth <span class="cm-builtin">date</span>,</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span>address <span class="cm-builtin">VARCHAR</span>(<span class="cm-number">20</span>),</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span>score <span class="cm-builtin">DOUBLE</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">);</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 293px;"></div><div class="CodeMirror-gutters" style="display: none; height: 293px;"></div></div></div></pre><hr /><h2><a name='header-n25' class='md-header-anchor '></a>07. 数值类型</h2><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="sql"><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="sql"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8.16406px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-builtin">TINYINT</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">SMALLINT</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-builtin">MEDIUMINT</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-builtin">INT</span> <span class="cm-keyword">OR</span> <span class="cm-builtin">INTEGER</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-builtin">BIGINT</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-builtin">FLOAT</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-builtin">DOUBLE</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-builtin">DECIMAL</span><span class="cm-tab" role="presentation" cm-text="	"> </span># <span class="cm-builtin">decimal</span>(M,D) <span class="cm-builtin">decimal</span>(<span class="cm-number">5</span>,<span class="cm-number">2</span>) == <span class="cm-number">123.45</span></span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 180px;"></div><div class="CodeMirror-gutters" style="display: none; height: 180px;"></div></div></div></pre><hr /><h2><a name='header-n28' class='md-header-anchor '></a>08. 字符串类型</h2><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="sql"><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="sql"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8.16406px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-builtin">CHAR</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-builtin">VARCHAR</span> <span class="cm-builtin">varchar</span>(<span class="cm-number">20</span>)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-builtin">TINYBLOB</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-builtin">TINYTEXT</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-builtin">BLOB</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-builtin">TEXT</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-builtin">MEDIUMBLOB</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-builtin">MEDIUMTEXT</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-builtin">LONGBLOB</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-builtin">LONGTEXT</span></span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 225px;"></div><div class="CodeMirror-gutters" style="display: none; height: 225px;"></div></div></div></pre><hr /><h2><a name='header-n31' class='md-header-anchor '></a>09. 日期类型</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n32" mdtype="fences">DATE	# YYYY-MM-DD
TIME	# HH:MM:SS
YEAR	# YYYY
DATETIME	# YYYY-MM-DD HH:MM:sS
TIMESTAMP	# YYYYMMDD HHMMSS

</pre><hr /><h2><a name='header-n34' class='md-header-anchor '></a>10. 查看当前数据库所有的表</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n35" mdtype="fences">-- 查看当前数据库所有的表
SHOW TABLES;

</pre><hr /><h2><a name='header-n37' class='md-header-anchor '></a>11. 查看指定表</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n38" mdtype="fences">-- 查看指定表
SHOW CREATE TABLE tablename;

</pre><hr /><h2><a name='header-n40' class='md-header-anchor '></a>12. 查看表结构</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n41" mdtype="fences">-- 查看表结构
DESC tablename;

</pre><hr /><h2><a name='header-n43' class='md-header-anchor '></a>13. 删除指定表</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n44" mdtype="fences">-- 删除表
DROP TABLE tablename;

</pre><hr /><h2><a name='header-n46' class='md-header-anchor '></a>14. 表中添加一列</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n47" mdtype="fences">-- 添加列
ALTER TABLE tablename ADD 列名 数据类型;

</pre><hr /><h2><a name='header-n49' class='md-header-anchor '></a>15. 修改列名和类型</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n50" mdtype="fences">-- 修改列名和类型
ALTER TABLE tablename CHANGE 原列名 修改列名 修改后的数据类型;

</pre><hr /><h2><a name='header-n52' class='md-header-anchor '></a>16. 删除列</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n53" mdtype="fences">-- 删除列
ALTER TABLE 表名 DROP 列名;

</pre><hr /><h2><a name='header-n55' class='md-header-anchor '></a>17. 修改表名</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n56" mdtype="fences">-- 修改表名
RENAME TABLE 原表名 TO 修改后的表名;

</pre><hr /><h2><a name='header-n58' class='md-header-anchor '></a>18. 表中数据插入</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n59" mdtype="fences">- 格式：INSERT INTO 表 (列名1,列名2,列名3...) VALUES (值1,值2,值3...);
- 格式：INSERT INTO 表 VALUES (值1,值2,值3...);	# 向表中插入所有列

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n60" mdtype="fences">INSERT INTO student (sid,name,gender,age,birth,address,score,dept) VALUES (1,'张三','男',18,'2001-12-23','河北',85.94,'dept'),(2,'张三','男',18,'2001-12-23','河北',85.94,'dept'),(3,'张三','男',18,'2001-12-23','河北',85.94,'dept'); # 可一次插入多行
INSERT INTO student VALUES (1004,'李四','男',18,'0201-12-23','河北',85.924,'dept');
INSERT INTO student (sid) VALUES (177);
INSERT INTO student (dept) VALUES ('dept_1');
INSERT INTO student (name,age) VALUES('王五',23);

</pre><hr /><h2><a name='header-n62' class='md-header-anchor '></a>19. 表中数据修改</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n63" mdtype="fences">- 格式：UPDATE 表名 SET 字段名 = 值,字段名 = 值...;
- 格式：UPDATE 表名 SET 字段名 = 值,字段名 = 值... WHERE 条件;

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n64" mdtype="fences">-- 将所有学生的地址修改为重庆 
UPDATE student SET address = '重庆';
-- 将所有学生id大于3的地址改为河北
UPDATE student SET address = '河北' where sid &gt;= 3;
-- 将id为4的学生的地址修改为广州，成绩修改为100，id改为6
update student SET address = '广州',score=100,sid = 6 where sid = 5;

update student SET score = score + 100 where sid = 3;

</pre><hr /><h2><a name='header-n66' class='md-header-anchor '></a>20. 表中数据删除</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n67" mdtype="fences">- 格式：DELETE FROM 表名 [WHERE 条件];
- 格式：TRUNCATE TABLE 表名 或 TRUNCATE 表名;

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n68" mdtype="fences">DELETE FROM student WHERE name = '王五';

</pre><hr /><h2><a name='header-n70' class='md-header-anchor '></a>21. 删除表中所有数据</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n71" mdtype="fences">-- 删除表中的所有数据
DELETE FROM tablename;

</pre><hr /><h2><a name='header-n73' class='md-header-anchor '></a>22. 清空表数据</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n74" mdtype="fences">-- 清空表数据
TRUNCATE TABLE tablename;
TRUNCATE tablename;

</pre><p><code>注意：delete和truncate原理不同，delete是只删除内容，而truncate类似于drop table，可以理解为是将整个表删除然后再创建该表。</code></p><p>&nbsp;</p><hr /><h2><a name='header-n78' class='md-header-anchor '></a>23. SQL约束</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n79" mdtype="fences"> 约束英文：constraint  将某一列作为唯一标识某一行
 约束实际上就是表中数据的限制条件
 表在设计的时候加入约束的目的就是为了保证表中的记录完整性和有效性，比如用户表有些列的值（手机号）不能为空，有些列的值（身份证号）不能重复。

 主键约束(primary key) PK
 自增长约束(auto_increment)
 非空约束(not null)
 唯一性约束(unique)
 默认约束(default)
 零填充约束(zerofill)
 外键约束(foreign key) FK

</pre><hr /><h2><a name='header-n81' class='md-header-anchor '></a>24. 主键约束</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n82" mdtype="fences">MySQL主键约束是一个列或者多个列的组合，其值能唯一地标识表中的每一行,方便在RDBMS中尽快的找到某一行。

主键约束相当于 唯一约束 + 非空约束 的组合，主键约束列不允许重复，也不允许出现空值。

每个表最多只允许一个主键

主键约束的关键字是：primary key

当创建主键的约束时，系统默认会在所在的列和列组合上建立对应的唯一索引。

</pre><hr /><h2><a name='header-n84' class='md-header-anchor '></a>25. 添加单列主键</h2><ul><li>创建单列主键有两种方式，一种是在定义字段的同时指定主键，一种是定义完字段之后指定主键</li><li>方式1-语法：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n90" mdtype="fences">create table 表名(
   ...
   &lt;字段名&gt; &lt;数据类型&gt; primary key 
   ...
)

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n91" mdtype="fences">create table tablename(
    eid INT PRIMARY KEY,
    name VARCHAR(20),
    deptId INT,
    salary DOUBLE
);

</pre><ul><li>方式2-语法：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n95" mdtype="fences">create table 表名(
   ...
   [constraint &lt;约束名&gt;] primary key (字段名)
);

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n96" mdtype="fences">create table tablename(
    eid INT,
    name VARCHAR(20),
    deptId INT,
    salary double,
    CONSTRAINT pk1 primary key (eid) # pk1为主键名 CONSTRAINT  pk1可省略
 );

</pre><ul><li>主键的作用：唯一标识一行数据</li><li>主键约束的列非空且唯一</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n102" mdtype="fences"> INSERT INTO tablename (eid,name,deptId,salary) VALUES(1,'张三',10,5000);
 # INSERT INTO tablename (eid,name,deptId,salary) VALUES(1,'张三',10,5000); 报错 主键eid必须唯一
  INSERT INTO tablename (eid,name,deptId,salary) VALUES(2,'  ',10,5000);
 # INSERT INTO tablename (eid,name,deptId,salary) VALUES(NULL,'王五',10,5000); 报错 主键eid不能为空

</pre><hr /><h2><a name='header-n104' class='md-header-anchor '></a>26. 添加联合主键</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n105" mdtype="fences"> 所谓的联合主键，就是这个主键是由一张表中多个字段组成的。
 注意：
    1. 当主键是由多个字段组成时，不能直接在字段名后面声明主键约束。
    2. 一张表只能有一个主键，联合主键也是一个主键
    3. 主键唯一 只要两个联合主键不是完全一样即可
    4. 作为联合主键时 任意一个都不能为空

</pre><ul><li>语法：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n109" mdtype="fences">create table 表名(
   ...
   primary key （字段1，字段2，…,字段n)
);

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n110" mdtype="fences">create table tablename( 
  name varchar(20), 
  deptId int, 
  salary double, 
  primary key (name,deptId) # CONSTRAINT pk2
);

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n111" mdtype="fences">INSERT INTO emp_3 VALUES ('张三',10,5000);
# INSERT INTO emp_3 VALUES ('张三',10,5000);
-- 报错 主键唯一 只要两个联合主键不是完全一样即可

INSERT INTO emp_3 VALUES ('张三',20,5000);
INSERT INTO emp_3 VALUES ('李四',10,5000);

-- 作为联合主键时 任意一个都不能为空
INSERT INTO emp_3 VALUES (NULL,10,5000);
INSERT INTO emp_3 VALUES ('张三',NULL,5000);
INSERT INTO emp_3 VALUES (NULL,NULL,5000);

</pre><hr /><h2><a name='header-n113' class='md-header-anchor '></a>27. 通过修改表结构添加主键</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n114" mdtype="fences">create table 表名(
   ...
);
alter table &lt;表名&gt; add primary key（字段列表);

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n115" mdtype="fences" style="break-inside: unset;">-- 添加单列主键
create table tablename(
  eid int, 
  name varchar(20), 
  deptId int, 
  salary double 
);
alter table tablename add primary key(eid);

-- 添加多列主键
CREATE TABLE tablename(
	eid INT,
	name VARCHAR(20),
	deptId INT,
	salary DOUBLE
);
ALTER TABLE tablename ADD PRIMARY KEY (name,deptId);

</pre><hr /><h2><a name='header-n117' class='md-header-anchor '></a>28. 删除主键约束</h2><ul><li>一个表中不需要主键约束时，就需要从表中将其删除。</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n121" mdtype="fences">alter table &lt;数据表名&gt; drop primary key;

</pre><hr /><h2><a name='header-n123' class='md-header-anchor '></a>29. 自增长约束</h2><ul><li>在MySQL中，当主键定义为自增长后，这个主键的值就不再需要用户输入数据了，而由数据库系统根据定义自动赋值。每增加一条记录，主键会自动以相同的步长进行增长。</li><li>通过给字段添加 auto_increment 属性来实现主键自增长</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n129" mdtype="fences">字段名 数据类型 auto_increment;

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n130" mdtype="fences">create table tablename( 
  id int primary key auto_increment, 
  name varchar(20) 
);

INSERT INTO tablename VALUES (NULL,'张三');
INSERT INTO tablename (name) VALUES ('李四');

</pre><ul><li>特点：</li></ul><ol start='' ><li>默认情况下，auto_increment的初始值是1，每新增一条记录，字段值自动加1。</li><li>一个表中只能有一个字段使用auto_increment约束，且该字段必须有唯一索引，以避免序号重复（即为主键或主键的一部分）。</li><li>auto_increment约束的字段必须具备 NOT NULL 属性。</li><li>auto_increment约束的字段只能是整数类型（TINYINT、SMALLINT、INT、BIGINT 等。</li><li>auto_increment约束字段的最大值受该字段的数据类型约束，如果达到上限，auto_increment就会失效。</li></ol><hr /><h2><a name='header-n146' class='md-header-anchor '></a>30. 指定自增字段初始值</h2><ul><li>如果第一条记录设置了该字段的初始值，那么新增加的记录就从这个初始值开始自增。</li><li>方式1，创建表时指定：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n152" mdtype="fences">create table tablename ( 
  id int primary key auto_increment, 
  name varchar(20)
) auto_increment=100;

</pre><ul><li>方式2，创建表后指定:</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n156" mdtype="fences">create table tablename ( 
  id int primary key auto_increment, 
  name varchar(20)
);
alter table tablename auto_increment = 1000;

</pre><p><strong>delete和truncate在删除后自增列的变化：</strong></p><ul><li>delete数据之后自动增长从断点开始</li><li>truncate数据之后自动增长从默认起始值开始</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n163" mdtype="fences">DELETE FROM tablename;
INSERT INTO tablename VALUES (NULL,'张三'); 
# DELETE删除数据之后，自增长还是在最后一个值的基础上+1
TRUNCATE tablename;
INSERT INTO tablename VALUES (NULL,'张三'); 
# TRUNCATE删除数据后，自增长从1开始，有初始值也是从1开始

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n164" mdtype="fences">DELETE from tablename WHERE id = 10;	# 删除最后一个数据后，再次添加数据仍从最后一个开始

</pre><hr /><h2><a name='header-n166' class='md-header-anchor '></a>31. 取消自增长</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n167" mdtype="fences">-- 删除主键（删除主键之前如果有自增约束，需要先删除自增约束）：
alter table 表名 drop primary key;

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n168" mdtype="fences">-- 取消自增长（取消自增长可以修改表字段，不再加自增约束即可）：
alter table 表名 change 字段名 字段名 数据类型;

</pre><ul><li>在新增自增长之前，也需要先添加主键，否则直接新增自增长，执行语法时会报错。</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n172" mdtype="fences">-- 修改id为主键
alter table 表名 change 字段名 字段名 数据类型 primary key;
-- 修改主键id为自增长
alter table 表名 change 字段名 字段名 数据类型 auto_increment;

</pre><hr /><h2><a name='header-n174' class='md-header-anchor '></a>32. 非空约束</h2><ul><li>非空约束（notnull）指字段的值不能为空。对于使用了非空约束的字段，如果用户在添加数据时没有指定值，数据库系统就会报错。</li><li>方式1，创建表时指定：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n180" mdtype="fences">&lt;字段名&gt;&lt;数据类型&gt; not null;

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n181" mdtype="fences">create table tablename ( 
  id int, 
  name varchar(20) not null, 
  address varchar(20) not null 
);

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n182" mdtype="fences">INSERT INTO tablename(id) VALUES (1);	-- 不可以
INSERT INTO tablename(id,name,address) VALUES(1,NULL,NULL);	-- 不可以
INSERT INTO tablename(id,name,address) VALUES(1,'NULL','NULL');	-- 可以(字符串：NULL)
INSERT INTO tablename(id,name,address) VALUES(2,'','');	-- 可以(空字符串)

</pre><ul><li>方式2，创建表后指定：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n186" mdtype="fences">alter table 表名 modify 字段 数据类型 not null;

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n187" mdtype="fences">create table tablename ( 
  id int , 
  name varchar(20) , -- 指定非空约束 
  address varchar(20) -- 指定非空约束 
); 
alter table tablename modify name varchar(20) not null; 
alter table tablename modify address varchar(20) not null;

</pre><hr /><h2><a name='header-n189' class='md-header-anchor '></a>33. 删除非空约束</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n190" mdtype="fences">alter table 表名 modify 字段 类型 

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n191" mdtype="fences">alter table tablename modify name varchar(20) ; 
alter table tablename modify address varchar(20) ;

</pre><p>&nbsp;</p><hr /><h2><a name='header-n194' class='md-header-anchor '></a>34. 唯一约束</h2><ul><li>唯一约束（Unique Key）是指所有记录中字段的值不能重复出现。例如，为 id 字段加上唯一性约束后，每条记录的 id 值都是唯一的，不能出现重复的情况。</li><li>方式1，创建表时指定：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n200" mdtype="fences">&lt;字段名&gt; &lt;数据类型&gt; unique

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n201" mdtype="fences">create table tablename ( 
 id int , 
 name varchar(20) , 
 phone_number varchar(20) unique -- 指定唯一约束 
);
INSERT into tablename VALUES(1,'张三','138');
INSERT into tablename VALUES(1,'张三','139');
INSERT into tablename VALUES(1,'张三',NULL);
INSERT into tablename VALUES(1,'张三',NULL);

</pre><p><code>mysql中NULL和任何值都不相同，包括和自己不同</code></p><p>方式2，创建表后指定：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n204" mdtype="fences"> alter table 表名 add constraint 约束名 unique (列);

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n205" mdtype="fences">create table tablename ( 
  id int , 
  name varchar(20) , 
  phone_number varchar(20) -- 指定唯一约束 
); 
alter table tablename add constraint unique_ph unique(phone_number);

</pre><hr /><h2><a name='header-n207' class='md-header-anchor '></a>35. 删除唯一约束</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n208" mdtype="fences">alter table &lt;表名&gt; drop index &lt;唯一约束名&gt;;

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n209" mdtype="fences">alter table tablename drop index unique_ph;

</pre><p><code>使用约束方式一时，默认将列名作为唯一约束名</code></p><hr /><h2><a name='header-n212' class='md-header-anchor '></a>36. 默认约束</h2><ul><li>MySQL 默认值约束用来指定某列的默认值。</li><li>方式,1，创建表时指定：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n218" mdtype="fences">&lt;字段名&gt; &lt;数据类型&gt; default &lt;默认值&gt;;

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n219" mdtype="fences">create table tablename ( 
  id int , 
  name varchar(20) ,
  address varchar(20) default '北京' -- 指定默认约束 
);

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n220" mdtype="fences">INSERT INTO tablename(id,name) VALUES(1,'张三');	-- 默认address张三
INSERT INTO tablename VALUES(2,'李四',NULL);	-- 赋值为NULL空
INSERT INTO tablename (id,name,address) VALUES(3,'王五','河北');	-- 使用给定值

</pre><ul><li>方式2，创建表后指定：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n224" mdtype="fences">alter table 表名 modify 列名 类型 default 默认值; 

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n225" mdtype="fences">create table tablename ( 
  id int , 
  name varchar(20) , 
  address varchar(20)  
);
alter table tablename modify address varchar(20) default  ‘北京’;

</pre><hr /><h2><a name='header-n227' class='md-header-anchor '></a>37. 删除默认约束</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n228" mdtype="fences">alter table &lt;表名&gt; modify column &lt;字段名&gt; &lt;类型&gt; default null; 

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n229" mdtype="fences">alter table tablename modify column address varchar(20) default null;

</pre><hr /><h2><a name='header-n231' class='md-header-anchor '></a>38. zerofill</h2><ol start='' ><li>插入数据时，当该字段的值的长度小于定义的长度时，会在该值的前面补上相应的0</li><li>zerofill默认为int(10)</li><li>当使用zerofill 时，默认会自动加unsigned（无符号）属性，使用unsigned属性后，数值范围是原值的2倍，例如，有符号为-128 ~ +127，无符号为0 ~ 256。</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n239" mdtype="fences">create table tablename ( 
  id int(3) zerofill , -- 零填充约束 3位
  name varchar(20)   
);

INSERT INTO t_user12 VALUES(1,'张三');
INSERT INTO t_user12 VALUES(10101,'张三');

</pre><ul><li>删除：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n243" mdtype="fences">alter table tablename modify id int	-- 删除后原有数据也不会补0

</pre><hr /><p><code>2022-06-04</code></p><hr /><p>﻿@<a href='%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86'>TOC</a></p><h1><a name='header-n248' class='md-header-anchor '></a>数据库-DQL</h1><h2><a name='header-n249' class='md-header-anchor '></a>01. 基本查询</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n250" mdtype="fences">SELECT 
  [ALL|DISTINCT]
  &lt;目标列的表达式1&gt; [别名],
  &lt;目标列的表达式2&gt; [别名]...
 FROM &lt;表名或视图名&gt; [别名],&lt;表名或视图名&gt; [别名]...
[WHERE&lt;条件表达式&gt;]
[GROUP BY &lt;列名&gt; 
[HAVING &lt;条件表达式&gt;]]
[ORDER BY &lt;列名&gt; [ASC|DESC]]
[LIMIT &lt;数字或者列表&gt;];
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n251" mdtype="fences">SELECT *| 列名 FROM 表 WHERE 条件
</pre><ul><li><strong>数据准备</strong></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n255" mdtype="fences" style="break-inside: unset;">	-- 创建数据库
	CREATE DATABASE IF NOT EXISTS mydb2;
	USE mydb2;
	
	-- 创建商品表：
	CREATE TABLE product(
	 pid INT PRIMARY KEY AUTO_INCREMENT, -- 商品编号
	 pname VARCHAR(20) NOT NULL , -- 商品名字
	 price DOUBLE,  -- 商品价格
	 category_id VARCHAR(20) -- 商品所属分类
	);
	
	-- 添加数据
	INSERT INTO product VALUES(NULL,'海尔洗衣机',5000,'c001');
	INSERT INTO product VALUES(NULL,'美的冰箱',3000,'c001');
	INSERT INTO product VALUES(NULL,'格力空调',5000,'c001');
	INSERT INTO product VALUES(NULL,'九阳电饭煲',200,'c001');
	INSERT INTO product VALUES(NULL,'啄木鸟衬衣',300,'c002');
	INSERT INTO product VALUES(NULL,'恒源祥西裤',800,'c002');
	INSERT INTO product VALUES(NULL,'花花公子夹克',440,'c002');
	INSERT INTO product VALUES(NULL,'劲霸休闲裤',266,'c002');
	INSERT INTO product VALUES(NULL,'海澜之家卫衣',180,'c002');
	INSERT INTO product VALUES(NULL,'杰克琼斯运动裤',430,'c002');
	 
	INSERT INTO product VALUES(NULL,'兰蔻面霜',300,'c003');
	INSERT INTO product VALUES(NULL,'雅诗兰黛精华水',200,'c003');
	INSERT INTO product VALUES(NULL,'香奈儿香水',350,'c003');
	INSERT INTO product VALUES(NULL,'SK-II神仙水',350,'c003');
	INSERT INTO product VALUES(NULL,'资生堂粉底液',180,'c003');
	 
	INSERT INTO product VALUES(NULL,'老北京方便面',56,'c004');
	INSERT INTO product VALUES(NULL,'良品铺子海带丝',17,'c004');
	INSERT INTO product VALUES(NULL,'三只松鼠坚果',88,NULL);
</pre><h2><a name='header-n256' class='md-header-anchor '></a>02. 简单查询</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n257" mdtype="fences">-- 查询表中所有数据
SELECT *  FROM tablename;

-- 查询表中指定列
SELECT 列名1,列名2,列名3,... FROM tablename;
</pre><h2><a name='header-n258' class='md-header-anchor '></a>03. 别名查询</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n259" mdtype="fences">别名查询.使用的关键字是as（as可以省略的）.  
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n260" mdtype="fences">-- 表别名
SELECT * FROM 表名 AS 别名;
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n261" mdtype="fences">-- 列别名
SELECT 列名1 AS 别名1,列名2 AS 别名2,... FROM 表名; 
</pre><h2><a name='header-n262' class='md-header-anchor '></a>04. distinct去重</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n263" mdtype="fences">-- 去除一模一样的一行
SELECT DISTINCT * FROM product;
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n264" mdtype="fences">-- 去掉某一列重复值
SELECT DISTINCT price FROM product; 

</pre><h2><a name='header-n265' class='md-header-anchor '></a>05. 运算查询</h2><ul><li>查询结果是表达式</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n269" mdtype="fences">-- 举例
SELECT pname,price+10 new_price FROM product;-- 不会修改原表 new_price为列别名

</pre><h2><a name='header-n270' class='md-header-anchor '></a>06. 算术运算符</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n271" mdtype="fences">算术运算符		 说明

+				加法运算
-				减法运算
*				乘法运算
/ 或  DIV		除法运算，返回商
% 或  MOD		求余运算，返回余数

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n272" mdtype="fences">SELECT 6 + 2;
SELECT 6 - 2;
SELECT 6 * 2;
SELECT 6 / 2;
SELECT 6 % 2;

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n273" mdtype="fences">-- 举例
-- 将所有商品的价格上调10%
SELECT pname,price * 1.1 AS new_price FROM product;

</pre><h2><a name='header-n274' class='md-header-anchor '></a>07. 比较运算符</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n275" mdtype="fences" style="break-inside: unset;">-- 比较运算符				说明
-- =						等于
-- &lt;和&lt;=					小于和小于等于
-- &gt;和&gt;=					大于和大于等于
-- &lt;=&gt;						安全的等于，两个操作码均为NULL时，其所得值为1；而当一个操作码为NULL时，其所得值为0
-- &lt;&gt;或!=					不等于
-- IS NULL或ISNULL			判断一个值是否为 NULL
-- IS NOT NULL				判断一个值是否不为 NULL
-- LEAST					当有两个或多个参数时，返回最小值
-- GREATEST					当有两个或多个参数时，返回最大值
-- BETWEEN AND				判断一个值是否落在两个值之间
-- IN						判断一个值是IN列表中的任意一个值
-- NOT IN					判断一个值不是IN列表中的任意一个值
-- LIKE						通配符匹配
-- REGEXP					正则表达式匹配

</pre><h2><a name='header-n276' class='md-header-anchor '></a>08. 逻辑运算符</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n277" mdtype="fences">逻辑运算符		说明

NOT 或者 !		逻辑非
AND 或者 &amp;&amp;		逻辑与
OR 或者 ||		逻辑或
XOR				逻辑异或

</pre><h2><a name='header-n278' class='md-header-anchor '></a>09. 位运算符</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n279" mdtype="fences">位运算符		说明

|			按位或
&amp;			按位与
^			按位异或
&lt;&lt; 			按位左移
&gt;&gt; 			按位右移
~			按位取反，反转所有比特

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n280" mdtype="fences" style="break-inside: unset;">```sql
-- select 3&amp;5; -- 位与
0 0 1 1 -- 3
0 1 0 1 -- 5
-------
0 0 0 1 -- 1

-- select 3|5; -- 位或
0 0 1 1 -- 3
0 1 0 1 -- 5
-------
0 1 1 1 -- 7

-- select 3^5; -- 位异或
0 0 1 1 -- 3
0 1 0 1 -- 5
-------
0 1 1 0 -- 6

-- select 3&gt;&gt;1; -- 位右移
0 0 1 1 &gt;&gt; 1 ---&gt; 0 0 0 1 -- 1

-- select 3&lt;&lt;1; -- 位左移
0 0 1 1 &lt;&lt; 1 ---&gt; 0 1 1 0 -- 6

-- select ~ 3;   -- 位取反 18446744073709551612
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1
-----------------------------------------------------------------
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0

</pre><p><code>位运算符是在二进制数上进行计算的运算符。位运算会先将操作数变成二进制数，进行位运算。然后再将计算结果从二进制数变回十进制数。</code></p><h2><a name='header-n282' class='md-header-anchor '></a>10. 条件查询</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n283" mdtype="fences">SELECT * FROM tablename WHERE 条件;

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n284" mdtype="fences">-- 查询价格不是800的所有商品
SELECT * FROM product WHERE price != 800;
SELECT * FROM product WHERE price &lt;&gt; 800;
SELECT * FROM product WHERE NOT(price = 800);

-- 查询商品价格是200或800的所有商品
SELECT * FROM product WHERE price = 200 OR price = 800;
SELECT * FROM product WHERE price IN (200,800);
SELECT * FROM product WHERE price = 200 || price = 800;

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n285" mdtype="fences" style="break-inside: unset;">-- 查询含有‘裤'字的所有商品
SELECT * FROM product WHERE pname LIKE '%裤%';-- %用来匹配任意字符
 
-- 查询以'海'开头的所有商品
SELECT * FROM product WHERE pname LIKE '海%';
 
-- 查询第二个字为'蔻'的所有商品
SELECT * FROM product WHERE pname LIKE '_蔻%';-- 一个下划线匹配单个字符
 
-- 查询category_id为null的商品
SELECT * FROM product WHERE category_id IS NULL;
 
-- 查询category_id不为null分类的商品
SELECT * FROM product WHERE category_id IS NOT NULL;

</pre><h2><a name='header-n286' class='md-header-anchor '></a>11. LEAST GREATEST</h2><ul><li>使用LEAST求最小值</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n290" mdtype="fences">SELECT LEAST(10, 20, 30); -- 10
SELECT LEAST(10, NULL , 30); -- null
SELECT LEAST(10, 20, 30) AS small_number;

</pre><ul><li>使用GREATEST求最大值</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n294" mdtype="fences">SELECT GREATEST(10, 20, 30);
SELECT GREATEST(10, NULL, 30); -- null

</pre><h2><a name='header-n295' class='md-header-anchor '></a>12. 排序查询</h2><ul><li>如果我们需要对读取的数据进行排序，我们就可以使用 MySQL 的 order by 子句来设定你想按哪个字段哪种方式来进行排序，再返回搜索结果。</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n299" mdtype="fences">SELECT 
 字段名1,字段名2,……
FROM 表名
ORDER BY 字段名1 [ASC|DESC]，字段名2[ASC|DESC]……

</pre><ul><li>特点</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n303" mdtype="fences">1.asc代表升序，desc代表降序，如果不写默认升序
2.order by用于子句中可以支持单个字段，多个字段，表达式，函数，别名
3.order by子句，放在查询语句的最后面。(LIMIT子句除外)

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n304" mdtype="fences">-- 1.使用价格排序(降序)
SELECT * FROM product ORDER BY price DESC;
-- 2.在价格排序(降序)的基础上，以分类排序(降序)
SELECT * FROM product ORDER BY price DESC,category_id DESC;
-- 3.显示商品的价格(去重复)，并排序(升序)
SELECT DISTINCT price FROM product ORDER BY price ASC;

</pre><h2><a name='header-n305' class='md-header-anchor '></a>13. 聚合查询</h2><ul><li>介绍：</li><li>使用聚合函数查询是纵向查询，它是对一列的值进行计算，然后返回一个单一的值；另外聚合函数会忽略空值。</li><li>聚合函数及其作用</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n313" mdtype="fences">-- 聚合函数		作用

-- count()	统计指定列不为NULL的记录行数；
-- sum()	计算指定列的数值和，如果指定列类型不是数值类型，那么计算结果为0
-- max()	计算指定列的最大值，如果指定列是字符串类型，那么使用字符串排序运算；
-- min()	计算指定列的最小值，如果指定列是字符串类型，那么使用字符串排序运算；
-- avg()	计算指定列的平均值，如果指定列类型不是数值类型，那么计算结果为0

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n314" mdtype="fences" style="break-inside: unset;">-- 1 查询商品的总条数
SELECT COUNT(*) FROM product;
SELECT COUNT(pid) FROM product;

-- 2 查询价格大于200商品的总条数
SELECT COUNT(*) FROM product WHERE price &gt; 200;

-- 3 查询分类为'c001'的所有商品的总和
SELECT SUM(price) FROM product WHERE category_id = 'c001';

-- 4 查询商品的最大价格
SELECT MAX(price) FROM product;

-- 5 查询商品的最小价格
SELECT MIN(price) FROM product;
SELECT MAX(price) max_price,MIN(price) min_price FROM product;

-- 6 查询分类为'c002'所有商品的平均价格
SELECT AVG(price) FROM product WHERE category_id = 'c002';

</pre><h2><a name='header-n315' class='md-header-anchor '></a>14. 聚合查询NULL的处理</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n316" mdtype="fences">1、count函数对null值的处理：
	如果count函数的参数为星号（*），则统计所有记录的个数。
	如果参数为某字段，不统计含null值的记录个数。

2、sum和avg函数对null值的处理：
	这两个函数忽略null值的存在，就好象该条记录不存在一样。

3、max和min函数对null值的处理：
	max和min两个函数同样忽略null值的存在。

</pre><ul><li>举例</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n320" mdtype="fences" style="break-inside: unset;">-- 创建表
CREATE TABLE tablename ( 
 c1 VARCHAR(20), 
 c2 INT -- c2 int default 0 null默认填充0
);

-- 插入数据
INSERT INTO tablename VALUES('aaa',3);
INSERT INTO tablename VALUES('bbb',3);
INSERT INTO tablename VALUES('ccc',NULL);
INSERT INTO tablename VALUES('ddd',6);
 
SELECT COUNT(*), COUNT(1), COUNT(c2) FROM tablename;--  4 4 3

SELECT SUM(c2),MAX(c2),MIN(c2),AVG(c2) FROM tablename;-- 12 6 3 4

</pre><h2><a name='header-n321' class='md-header-anchor '></a>15. 分组查询 </h2><ul><li>分组查询是指使用group by字句对查询信息进行分组。</li><li>group by 后可加多个分组字段，只有当全部相同时才能分到同一组</li><li>如果要进行分组的话，则SELECT子句之后，只能出现分组的字段和统计函数，其他的字段不能出现</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n329" mdtype="fences">select 字段1,字段2… from 表名 group by 分组字段 having 分组条件;

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n330" mdtype="fences">-- 统计各个分类商品的个数
SELECT category_id,COUNT(*) FROM product GROUP BY category_id ;

</pre><h2><a name='header-n331' class='md-header-anchor '></a>16. having条件筛选</h2><ul><li>分组之后的条件筛选-having </li><li>分组之后对统计结果进行筛选的话必须使用having，不能使用where</li><li>where子句用来筛选 FROM 子句中指定的操作所产生的行 </li><li>group  by  子句用来分组 WHERE 子句的输出。 </li><li>having 子句用来从分组的结果中筛选行</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n343" mdtype="fences">SELECT 字段1,字段2… FROM 表名 GROUP BY 分组字段 HAVING 分组条件;

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n344" mdtype="fences">-- 2.统计各个分类商品的个数,且只显示个数大于4的信息
-- select --&gt; from --&gt; where --&gt; group by --&gt; having --&gt; order by
SELECT category_id ,COUNT(*) FROM product GROUP BY category_id HAVING COUNT(*) &gt; 1;
SELECT category_id ,COUNT(*) AS 总和 FROM product GROUP BY category_id HAVING 总和 &gt; 1 ORDER BY 总和 ASC;

</pre><h2><a name='header-n345' class='md-header-anchor '></a>17. 分页查询</h2><ul><li>分页查询：例如数据共有30条，每页显示5条，第一页显示1-5条，第二页显示6-10条。</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n349" mdtype="fences">-- 方式1-显示前n条
SELECT 字段1，字段2... FROM 表名 LIMIT n

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n350" mdtype="fences">-- 方式2-分页显示
SELECT 字段1，字段2... FROM 表名 LIMIT m,n

参数：
	m: 整数，表示从第几条索引开始，计算方式 （当前页-1）* 每页显示条数
	n: 整数，表示查询多少条数据

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n351" mdtype="fences">-- 查询product表的前5条记录 
SELECT * FROM product LIMIT 5 ;

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n352" mdtype="fences">-- 从第4条开始显示，显示5条 
SELECT * FROM product LIMIT 3,5 ;

</pre><ul><li>分页显示：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n356" mdtype="fences">SELECT * FROM product LIMIT 0,6;-- 第1页 (1 - 1) * 6
SELECT * FROM product LIMIT 6,6;-- 第2页 (2 - 1) * 6
SELECT * FROM product LIMIT 12,6;-- 第3页 (3 - 1) * 6

SELECT * FROM product LIMIT (n-1)*6,6;-- 第n页 (n - 1) * 6

</pre><h2><a name='header-n357' class='md-header-anchor '></a>18. INSERT INTO SELECT</h2><ul><li>将一张表的数据导入到另一张表中，可以使用INSERT INTO SELECT语句 。</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n361" mdtype="fences">格式：
--要求目标表Table2必须存在
insert into Table2(field1,field2,…) select value1,value2,… from Table1;
insert into Table2 select * from Table1;

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n362" mdtype="fences">CREATE TABLE product2(
    pname VARCHAR(20),
    price DOUBLE
);

INSERT INTO product2(pname,price) SELECT pname,price FROM product;
SELECT * FROM product2;

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n363" mdtype="fences">CREATE TABLE product3(
	category_id VARCHAR(20),
	product_count INT 
);

INSERT INTO product3 SELECT category_id,COUNT(*) FROM product GROUP BY category_id;
SELECT * FROM product3;

</pre><p>&nbsp;</p><h2><a name='header-n365' class='md-header-anchor '></a>19. SELECT INTO FROM</h2><ul><li>将一张表的数据导入到另一张表中，有两种选择 SELECT INTO FROM 和 INSERT INTO SELECT 。</li><li>要求目标表Table2不存在，因为在插入时会自动创建表Table2，并将Table1中指定字段数据复制到Table2中。</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n371" mdtype="fences">SELECT vale1, value2 into Table2 from Table1

</pre><ul><li>MySQL中不支持上面格式，可以写为：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n375" mdtype="fences"> CREATE TABLE  tableName2 (SELECT  column_name1,column_name2,....  FROM tableName1);

</pre><h2><a name='header-n376' class='md-header-anchor '></a>20. 正则表达式</h2><ul><li>正则表达式(regular expression)描述了一种字符串匹配的规则，</li><li>正则表达式本身就是一个字符串，</li><li>使用这个字符串来描述、用来定义匹配规则，匹配一系列符合某个句法规则的字符串。</li><li>在开发中，正则表达式通常被用来检索、替换那些符合某个规则的文本。</li><li>MySQL通过REGEXP关键字支持正则表达式进行字符串匹配。</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n388" mdtype="fences">模式			描述

^			匹配输入字符串的开始位置。
$			匹配输入字符串的结束位置。
.			匹配除 "\n" 之外的任何单个字符。
[...]		字符集合。匹配所包含的任意一个字符。例如， '[abc]' 可以匹配 "plain" 中的 'a'。
[^...]		负值字符集合。匹配未包含的任意字符。例如， '[^abc]' 可以匹配 "plain" 中的'p'。
p1|p2|p3	匹配 p1 或 p2 或 p3。例如，'z|food' 能匹配 "z" 或 "food"。'(z|f)ood' 则匹配 "zood" 或 "food"。
*			匹配前面的子表达式零次或多次。例如，zo* 能匹配 "z" 以及 "zoo"。* 等价于{0,}。
+			匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}。
{n}			n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o。
{n,m}		m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。

</pre><ul><li>操作举例：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n392" mdtype="fences" style="break-inside: unset;">-- ^ 在字符串开始处进行匹配
SELECT  'abc' REGEXP '^a';		-- 1 字符串是否以a开头
SELECT * FROM product WHERE pname REGEXP '^海';
 
-- $ 在字符串末尾开始匹配
SELECT  'abc' REGEXP 'a$';		-- 0 字符串是否以a结尾
SELECT  'abc' REGEXP 'c$';		-- 1
SELECT * FROM product WHERE pname REGEXP '水$';

--  . 匹配任意字符 除换行符
SELECT  'abc' REGEXP '.b';		-- 1
SELECT  'abc' REGEXP '.c';		-- 1
SELECT  'abc' REGEXP 'a.';		-- 1
 
-- [...] 匹配括号内的任意单个字符
SELECT  'abc' REGEXP '[xyz]';		-- 0 任意字符是否出现在前面的字符串中
SELECT  'abc' REGEXP '[xaz]';		-- 1

-- [^...] 注意^符合只有在[]内才是取反的意思，在别的地方都是表示开始处匹配
SELECT  'a' REGEXP '[^abc]';		-- 0 任意字符是否都未出现在前面的字符串中
SELECT  'x' REGEXP '[^abc]';		-- 1 匹配除abc之外的任何字符，如果有则为1，否则为0
SELECT  'abc' REGEXP '[^a]';		-- 1 除了a之外其他字符是否在前面的字符串中出现
 
-- a* 匹配0个或多个a,包括空字符串。 可以作为占位符使用.有没有指定字符都可以匹配到数据
SELECT 'stab' REGEXP '.ta*b';		-- 1 a可以出现0次或多次
SELECT 'stab' REGEXP '.(ta)*b';		-- 1
SELECT 'stb' REGEXP '.ta*b';		-- 1
SELECT '' REGEXP 'a*';				-- 1
 
-- a+  匹配1个或者多个a,但是不包括空字符
SELECT 'stab' REGEXP '.ta+b';		-- 1 a至少出现1次
SELECT 'stb' REGEXP '.ta+b';		-- 0

-- a?  匹配0个或者1个a
SELECT 'stb' REGEXP '.ta?b';		-- 1 a为1或0个
SELECT 'stab' REGEXP '.ta?b';		-- 1
SELECT 'staab' REGEXP '.ta?b';		-- 0
 
-- a1|a2  匹配a1或者a2，
SELECT 'a' REGEXP 'a|b';			-- 1
SELECT 'b' REGEXP 'a|b';			-- 1
SELECT 'bcc' REGEXP '^(a|b)';		-- 1 以a或b开头
SELECT 'a' REGEXP '^(a|b)';			-- 1
SELECT 'c' REGEXP '^(a|b)';			-- 0
 
-- a{m} 匹配m个a
SELECT 'auuuuc' REGEXP 'au{4}c';	-- 1 u恰好出现4次
SELECT 'auuuuc' REGEXP 'au{3}c';	-- 0

-- a{m,} 匹配m个或更多个a
SELECT 'auuuuc' REGEXP 'au{3,}c';	-- 1
SELECT 'auuuuc' REGEXP 'au{4,}c';	-- 1
SELECT 'auuuuc' REGEXP 'au{5,}c';	-- 0

 -- a{m,n} 匹配m到n个a,包含m和n
SELECT 'auuuuc' REGEXP 'au{3,5}c';	-- 1
SELECT 'auuuuc' REGEXP 'au{4,5}c';	-- 1
SELECT 'auuuuc' REGEXP 'au{5,10}c';	-- 0
 
-- (abc) abc作为一个序列匹配，不用括号括起来都是用单个字符去匹配，如果要把多个字符作为一个整体去匹配就需要用到括号，所以括号适合上面的所有情况。
SELECT 'xababy' REGEXP 'x(abab)y';	-- 1
SELECT 'xababy' REGEXP 'x(ab)*y';	-- 1
SELECT 'xababy' REGEXP 'x(ab){1,2}y';	-- 1
SELECT 'xababy' REGEXP 'x(ab){3,}y';	-- 0

</pre><h2><a name='header-n393' class='md-header-anchor '></a>21. 多表操作</h2><ul><li>多表关系：
MySQL多表之间的关系可以概括为：一对一、一对多/多对一关系，多对多</li><li>一对一关系：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n399" mdtype="fences">1. 一个学生只有一张身份证；一张身份证只能对应一学生。
2. 在任一表中添加唯一外键，指向另一方主键，确保一对一关系。
3. 一般一对一关系很少见，遇到一对一关系的表最好是合并表。

</pre><ul><li>一对多/多对一关系：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n403" mdtype="fences">1. 部门和员工：一个部门有多个员工，一个员工只能对应一个部门
2. 实现原则：在多的一方建立外键，指向一的一方的主键

</pre><ul><li>多对多关系：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n407" mdtype="fences">1. 学生和课程：一个学生可以选择很多门课程，一个课程也可以被很多学生选择
2. 原则：多对多关系实现需要借助第三张中间表。.
3. 中间表至少包含两个字段，将多对多的关系，拆成一对多的关系，中间表至少要有两个外键，这两个外键分别指向原来的那两张表的主键

</pre><ul><li>数据准备：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n411" mdtype="fences" style="break-inside: unset;">deptid	deptname
1001	研发部
1002	销售部
1003	财务部
1004	人事部

eid	ename	   age  	dept_id
1	name1	   	20		1001
2	name2		21		1001
3	name3		23		1001
4	name4		18		1001
5	name5		85		1002
6	name6		33		1002
7	name7		50		1002
8	name8		60		1003
9	name9		58		1003
10	name10	  	71 	 	1005

</pre><h2><a name='header-n412' class='md-header-anchor '></a>22. 外键约束:一对多关系</h2><ul><li><p>外键约束</p></li><li><p>MySQL 外键约束（FOREIGN KEY）是表的一个特殊字段，经常与主键约束一起使用。</p></li><li><p>对于两个具有关联关系的表而言，相关联字段中主键所在的表就是主表（父表），外键所在的表就是从表（子表）。</p></li><li><p>外键用来建立主表与从表的关联关系，为两个表的数据建立连接，约束两个表中数据的一致性和完整性。</p></li><li><p>特点：定义一个外键时，需要遵守下列规则：</p><ul><li>主表必须已经存在于数据库中，或者是当前正在创建的表。</li></ul></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n427" mdtype="fences">外键约束-一对多关系：
	必须为主表定义主键。
	主键不能包含空值，但允许在外键中出现空值。(只要外键的每个非空值出现在指定的主键中，这 个外键的内容就是正确的。)
	在主表的表名后面指定列名或列名的组合。这个列或列的组合必须是主表的主键或候选键。
	外键中列的数目必须和主表的主键中列的数目相同。
	外键中列的数据类型必须和主表主键中对应列的数据类型相同。

</pre><ul><li>创建外键约束</li><li>在创建表时创建外键：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n433" mdtype="fences">在 create table 语句中，通过 foreign key 关键字来指定外键，具体的语法格式如下：
[CONSTRAINT &lt;外键名&gt;] FOREIGN KEY 字段名 [，字段名2，…] REFERENCES &lt;主表名&gt; 主键列1 [，主键列2，…]

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n434" mdtype="fences" style="break-inside: unset;">-- 主表
CREATE TABLE IF NOT EXISTS dept(
  deptid VARCHAR(20) PRIMARY KEY ,  -- 部门号
  deptname VARCHAR(20) -- 部门名字
);

-- 从表
CREATE TABLE IF NOT EXISTS emp(
  eid VARCHAR(20) PRIMARY KEY , -- 员工编号
  ename VARCHAR(20), -- 员工名字
  age INT,  -- 员工年龄
  dept_id VARCHAR(20),  -- 员工所属部门
  CONSTRAINT emp_fk FOREIGN KEY (dept_id) REFERENCES dept (deptid) -- 外键约束 emp_fk 为外键名字(便于删除)，dept_id指定外键列，dept主表，deptno主键列
);

</pre><ul><li>在创建表后设置外键约束：</li><li><code>外键约束也可以在修改表时添加，但是添加外键约束的前提是：</code></li><li><code>从表中外键列中的数据必须与主表中主键列中的数据一致或者是没有数据。</code></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n442" mdtype="fences">ALTER TABLE &lt;数据表名&gt; ADD CONSTRAINT &lt;外键名&gt; FOREIGN KEY(&lt;列名&gt;) REFERENCES &lt;主表名&gt; (&lt;列名&gt;);

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n443" mdtype="fences" style="break-inside: unset;">-- 创建部门表
CREATE TABLE IF NOT EXISTS dept(
  deptid VARCHAR(20) PRIMARY KEY ,  -- 部门号
  NAME VARCHAR(20) -- 部门名字
);

-- 创建员工表
CREATE TABLE IF NOT EXISTS emp(
  eid VARCHAR(20) PRIMARY KEY , -- 员工编号
  ename VARCHAR(20), -- 员工名字
  age INT,  -- 员工年龄
  dept_id VARCHAR(20)  -- 员工所属部门
);

-- 创建外键约束
ALTER TABLE emp ADD CONSTRAINT dept_id_fk FOREIGN KEY(dept_id) REFERENCES dept (deptid);

</pre><h2><a name='header-n444' class='md-header-anchor '></a>23. 外键约束下的数据操作</h2><p>1、数据插入：注意必须先给主表添加数据</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n446" mdtype="fences">INSERT INTO dept VALUES('1001','研发部');
INSERT INTO dept VALUES('1002','销售部');
INSERT INTO dept VALUES('1003','财务部');
INSERT INTO dept VALUES('1004','人事部');

</pre><p>2、添加从表数据：外键列的值必须依赖主表的主键列</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n448" mdtype="fences">INSERT INTO emp VALUES('1','name1',20, '1001');
INSERT INTO emp VALUES('2','name2',21, '1001');
INSERT INTO emp VALUES('3','name3',23, '1001');
INSERT INTO emp VALUES('4','name4',18, '1002');
INSERT INTO emp VALUES('5','name5',35, '1002');
INSERT INTO emp VALUES('6','name6',33, '1003');
INSERT INTO emp VALUES('7','name7',50, '1003'); 

-- 报错
INSERT INTO emp VALUES('8','name8',60, '1005');

</pre><h2><a name='header-n449' class='md-header-anchor '></a>24. 外键约束下的数据删除</h2><p>1、主表的数据被从表依赖时，不能删除，否则可以删除
2、从表的数据可以随便删除</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n451" mdtype="fences">DELETE FROM dept WHERE deptid = '1001'; -- 不可以删除
DELETE FROM dept WHERE deptid = '1004'; -- 可以删除
DELETE FROM emp WHERE eid = '7'; -- 可以删除

</pre><h2><a name='header-n452' class='md-header-anchor '></a>25. 删除外键约束</h2><ul><li>当一个表中不需要外键约束时，就需要从表中将其删除。外键一旦删除，就会解除主表和从表间的关联关系。</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n456" mdtype="fences">ALTER TABLE &lt;表名&gt; DROP FOREIGN KEY &lt;外键约束名&gt;;

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n457" mdtype="fences">-- 实现：
ALTER TABLE emp DROP FOREIGN KEY emp_fk;

</pre><h2><a name='header-n458' class='md-header-anchor '></a>26. 外键约束:多对多关系</h2><ul><li>在多对多关系中，A表的一行对应B的多行，B表的一行对应A表的多行，我们要新增加一个中间表，来建立多对多关系。</li><li>操作：学生表和课程表(多对多)</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n464" mdtype="fences" style="break-inside: unset;">-- 1 创建学生表student(左侧主表)
CREATE TABLE IF NOT EXISTS student(
    sid INT PRIMARY KEY AUTO_INCREMENT,
    studentname VARCHAR(20),
    age INT,
    gender VARCHAR(20)
);

-- 2 创建课程表course(右侧主表)
CREATE TABLE course(
	cid  INT PRIMARY KEY AUTO_INCREMENT,
	coursename VARCHAR(20)
);

-- 3 创建中间表student_course(从表)
CREATE TABLE student_course(
	sid INT,
	cid INT,
	score DOUBLE
);

-- 4 建立外键约束(2次)
ALTER TABLE student_course ADD CONSTRAINT sid FOREIGN KEY(sid) REFERENCES student(sid);
ALTER TABLE student_course ADD CONSTRAINT cid FOREIGN KEY(cid) REFERENCES course (cid);

-- 5 添加联合主键
ALTER TABLE student_course ADD PRIMARY KEY (cid,sid);

-- 6 给学生表添加数据
INSERT INTO student VALUES(1,'stuname1',18,'女'),(2,'stuname2',19,'女'),(3,'stuname3',20,'男');

-- 7 给课程表添加数据
INSERT INTO course VALUES(1,'语文'),(2,'数学'),(3,'英语');

-- 8 给中间表添加数据
INSERT INTO student_course  VALUES(1,1,10),(1,2,20),(2,1,30),(2,3,40),(3,2,50),(3,3,60);

-- 9 修改和删除：中间从表可以随便修改和删除，但是两边的主表受从表依赖的数据不能删除或者修改。

-- 10 删除外键约束
ALTER TABLE student_course DROP FOREIGN KEY cid;
ALTER TABLE student_course DROP FOREIGN KEY sid;

</pre><h2><a name='header-n465' class='md-header-anchor '></a>27. 多表联合查询</h2><ul><li>多表查询就是同时查询两个或两个以上的表</li></ul><ol start='' ><li>交叉连接查询 [产生笛卡尔积]</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n472" mdtype="fences">SELECT * FROM A,B;  

</pre><ol start='2' ><li>内连接查询</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n476" mdtype="fences">-- 隐式内连接（SQL92标准）：
SELECT * FROM A,B WHERE 条件;
-- 显示内连接（SQL99标准）：
SELECT * FROM A INNER JOIN B ON 条件; -- inner可省略

</pre><ol start='3' ><li>外连接查询</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n480" mdtype="fences">-- 左外连接：
SELECT * FROM A LEFT OUTER JOIN B ON 条件;	-- outer可省略
-- 右外连接：
RIGHT OUTER JOIN
SELECT * FROM A RIGHT OUTER JOIN B ON 条件;	-- outer可省略
-- 满外连接: 
FULL OUTER JOIN
SELECT * FROM A FULL OUTER JOIN B ON 条件;	-- outer可省略

</pre><ol start='4' ><li>子查询：select的嵌套</li><li>表自关联：将一张表当成多张表来用</li></ol><p><code>外键约束对多表查询无影响。</code></p><h2><a name='header-n487' class='md-header-anchor '></a>28. 交叉连接查询</h2><ul><li>数据准备</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n491" mdtype="fences" style="break-inside: unset;">-- 创建部门表
CREATE TABLE IF NOT EXISTS dept(
  deptid VARCHAR(20) PRIMARY KEY ,  -- 部门号
  NAME VARCHAR(20) -- 部门名字
);

-- 创建员工表
CREATE TABLE IF NOT EXISTS emp(
  eid VARCHAR(20) PRIMARY KEY , -- 员工编号
  ename VARCHAR(20), -- 员工名字
  age INT,  -- 员工年龄
  dept_id VARCHAR(20)  -- 员工所属部门
);

-- 创建外键约束
ALTER TABLE emp ADD CONSTRAINT dept_id_fk FOREIGN KEY(dept_id) REFERENCES dept (deptid);

-- 数据插入
INSERT INTO dept VALUES('1001','研发部');
INSERT INTO dept VALUES('1002','销售部');
INSERT INTO dept VALUES('1003','财务部');
INSERT INTO dept VALUES('1004','人事部');
INSERT INTO emp VALUES('1','name1',20, '1001');
INSERT INTO emp VALUES('2','name2',21, '1001');
INSERT INTO emp VALUES('3','name3',23, '1001');
INSERT INTO emp VALUES('4','name4',18, '1002');
INSERT INTO emp VALUES('5','name5',35, '1002');
INSERT INTO emp VALUES('6','name6',33, '1003');
INSERT INTO emp VALUES('7','name7',50, '1003'); 

</pre><ul><li>交叉连接查询：</li></ul><ol start='' ><li>交叉连接查询返回被连接的两个表所有数据行的笛卡尔积</li><li>笛卡尔积可以理解为一张表的每一行去和另外一张表的任意一行进行匹配</li><li>假如A表有m行数据，B表有n行数据，则返回m*n行数据</li><li>笛卡尔积会产生很多冗余的数据，后期的其他查询可以在该集合的基础上进行条件筛选</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n504" mdtype="fences">SELECT * FROM 表1,表2,表3….; 

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n505" mdtype="fences">SELECT * FROM dept,emp;

</pre><h2><a name='header-n506' class='md-header-anchor '></a>29. 内连接查询</h2><ul><li>内连接查询求多张表的交集</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n510" mdtype="fences">-- 隐式内连接（SQL92标准）：
SELECT * FROM A,B WHERE 条件; 
-- 显示内连接（SQL99标准）：
SELECT * FROM A INNER JOIN B ON 条件;

</pre><ul><li>操作</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n514" mdtype="fences">SELECT * FROM dept,emp WHERE deptid = dept_id;
SELECT * FROM dept d,emp e WHERE d.deptid = e.dept_id;
SELECT * FROM dept,emp WHERE dept.deptid = emp.dept_id;
SELECT * FROM dept INNER JOIN emp ON dept.deptid = emp.dept_id;
SELECT * FROM dept,emp WHERE dept.deptid = emp.dept_id AND NAME = '研发部';
SELECT * FROM dept,emp WHERE dept.deptid = emp.dept_id AND (NAME ='研发部' OR NAME = '销售部');
SELECT * FROM dept,emp WHERE dept.deptid = emp.dept_id AND NAME IN( '研发部','销售部');
SELECT * FROM dept JOIN emp ON dept.deptid = emp.dept_id AND NAME IN( '研发部','销售部');

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n515" mdtype="fences">-- 查询每个部门的员工数,并升序排序
SELECT deptid,COUNT(1) AS total_cnt FROM dept,emp WHERE dept.deptid = emp.dept_id GROUP BY deptid ORDER BY total_cnt;

SELECT dept.name,deptid,COUNT(1) AS total_cnt FROM dept JOIN emp ON dept.deptid = emp.dept_id GROUP BY deptno ORDER BY total_cnt;

SELECT dept.name,deptid,COUNT(1) AS total_cnt FROM dept JOIN emp ON dept.deptid = emp.dept_id GROUP BY deptid,dept.name ORDER BY total_cnt;

-- 查询人数大于等于3的部门，并按照人数降序排序
SELECT deptid,dept.name,COUNT(1) AS total_cnt FROM dept,emp WHERE dept.deptid = emp.dept_id GROUP BY deptid HAVING total_cnt &gt;= 3 ORDER BY total_cnt DESC;

SELECT deptid,dept.name,COUNT(1) AS total_cnt FROM dept JOIN emp ON dept.deptid = emp.dept_id GROUP BY deptid HAVING total_cnt &gt;= 3 ORDER BY total_cnt DESC;

</pre><h2><a name='header-n516' class='md-header-anchor '></a>30. 外连接查询</h2><ul><li>外连接分为左外连接（left outer join）、右外连接(right outer join)，满外连接(full outer join)。</li><li>oracle里面有full join，但在mysql对full join支持的不好，可以使用union来达到目的。</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n522" mdtype="fences">-- 左外连接：
LEFT OUTER JOIN
SELECT * FROM A LEFT OUTER JOIN B ON 条件;
-- 右外连接：
RIGHT OUTER JOIN
SELECT * FROM A RIGHT OUTER JOIN B ON 条件;
-- 满外连接: 
FULL OUTER JOIN
SELECT * FROM A FULL OUTER JOIN B ON 条件;

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n523" mdtype="fences" style="break-inside: unset;">SELECT 
*
FROM A
	RIGHT JOIN B ON 条件1
	RIGHT JOIN C ON 条件2
	RIGHT JOIN D ON 条件3;
	
SELECT 
*
FROM A
	LEFT JOIN B ON 条件1
	LEFT JOIN C ON 条件2
	LEFT JOIN D ON 条件3;

</pre><ul><li>操作</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n527" mdtype="fences">SELECT * FROM dept d LEFT OUTER JOIN emp e ON d.deptid = e.dept_id;
SELECT * FROM dept RIGHT OUTER JOIN emp ON dept.deptid = emp.dept_id;

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n528" mdtype="fences">-- 使用union关键字实现左外连接和右外连接的并集

SELECT * FROM dept LEFT OUTER JOIN emp ON dept.deptid = emp.dept_id UNION -- 去重
SELECT * FROM dept RIGHT OUTER JOIN emp ON dept.deptid = emp.dept_id;

SELECT * FROM dept LEFT OUTER JOIN emp ON dept.deptid = emp.dept_id UNION ALL -- 不去重
SELECT * FROM dept RIGHT OUTER JOIN emp ON dept.deptid = emp.dept_id;

</pre><h2><a name='header-n529' class='md-header-anchor '></a>31. 子查询</h2><ul><li><p>子查询就是指的在一个完整的查询语句之中，嵌套若干个不同功能的小查询，从而一起完成复杂查询的一种编写形式</p></li><li><p>select语句嵌套</p></li><li><p>子查询可以返回的数据类型一共分为四种：</p><ul><li>单行单列：返回的是一个具体列的内容，可以理解为一个单值数据；</li><li>单行多列：返回一行数据中多个列的内容；</li><li>多行单列：返回多行记录之中同一列的内容，相当于给出了一个操作范围；</li><li>多行多列：查询返回的结果是一张临时表</li></ul></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n546" mdtype="fences">SELECT eid,ename,age FROM emp WHERE age = (SELECT MAX(age) FROM emp); -- 单行单列，可以作为一个值用
-- 查询研发部和销售部的员工信息，包含员工号、员工名字
SELECT eid,ename FROM emp WHERE dept_id IN (SELECT deptid FROM dept WHERE NAME = '研发部' OR NAME = '销售部') ;-- 单列多行
-- 查询研发部20岁以下的员工信息,包括员工号、员工名字，部门名字
SELECT * FROM (SELECT * FROM dept WHERE NAME = '研发部 ') t1 JOIN (SELECT * FROM emp WHERE age &lt;25) t2 ON t1.deptid = t2.dept_id;-- 多行多列

</pre><h2><a name='header-n547' class='md-header-anchor '></a>32. 子查询关键字</h2><ul><li>子查询关键字-ALL</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n551" mdtype="fences">SELECT …from …where c &gt; ALL(查询语句)
等价于
SELECT ...from ... WHERE c &gt; result1 and c &gt; result2 and c &gt; result3

</pre><ul><li>特点：</li></ul><ol start='' ><li>ALL: 与子查询返回的所有值比较为true 则返回true</li><li>ALL可以与=、&gt;、&gt;=、&lt;、&lt;=、&lt;&gt;结合是来使用，分别表示等于、大于、大于等于、小于、小于等于、不等于其中的其中的所有数据。</li><li>ALL表示指定列中的值必须要大于子查询集的每一个值，即必须要大于子查询集的最大值；如果是小于号即小于子查询集的最小值。同理可以推出其它的比较运算符的情况。</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n562" mdtype="fences">-- 查询年龄大于'1003'部门所有年龄的员工信息
SELECT * FROM emp WHERE age &gt; ALL(SELECT age FROM emp WHERE dept_id = '1003');
-- 查询不属于任何一个部门的员工信息 
SELECT * FROM emp WHERE dept_id != ALL(SELECT deptid FROM dept); 

</pre><ul><li>子查询关键字-ANY和SOME：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n566" mdtype="fences">SELECT …from …where c &gt; ANY(查询语句)
-- 等价于：
SELECT ...from ... WHERE c &gt; result1 or c &gt; result2 or c &gt; result3;

</pre><ul><li>特点:</li></ul><ol start='' ><li>ANY:与子查询返回的任何值比较为true 则返回true</li><li>ANY可以与=、&gt;、&gt;=、&lt;、&lt;=、&lt;&gt;结合是来使用，分别表示等于、大于、大于等于、小于、小于等于、不等于其中的其中的任何一个数据。</li><li>表示制定列中的值要大于子查询中的任意一个值，即必须要大于子查询集中的最小值。同理可以推出其它的比较运算符的情况。</li><li>SOME和ANY的作用一样，SOME可以理解为ANY的别名</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n579" mdtype="fences">-- 查询年龄大于'1003'部门任意一个员工年龄的员工信息
SELECT * FROM emp WHERE age &gt; ANY(SELECT age FROM emp WHERE dept_id = '1003') AND dept_id != '1003';

</pre><ul><li>子查询关键字-IN：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n583" mdtype="fences">SELECT …from …where c IN(查询语句)
-- 等价于：
SELECT ...from ... WHERE c = result1 or c = result2 or c = result3

</pre><ul><li>特点：</li></ul><ol start='' ><li>IN关键字，用于判断某个记录的值，是否在指定的集合中</li><li>在IN关键字前边加上not可以将条件反过来</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n592" mdtype="fences">-- 查询研发部和销售部的员工信息，包含员工号、员工名字
SELECT * FROM emp WHERE dept_id IN (SELECT deptid FROM dept WHERE NAME IN ('研发部','销售部')) ;

</pre><ul><li>子查询关键字-EXISTS：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n596" mdtype="fences">SELECT …from …where EXISTS(查询语句)

</pre><ul><li>特点：</li></ul><ol start='' ><li>该子查询如果“有数据结果”(至少返回一行数据)， 则该EXISTS() 的结果为“true”，外层查询执行</li><li>该子查询如果“没有数据结果”（没有任何数据返回），则该EXISTS()的结果为“false”，外层查询不执行</li><li>EXISTS后面的子查询不返回任何实际数据，只返回真或假，当返回真时 where条件成立</li><li>注意，EXISTS关键字，比IN关键字的运算效率高，因此，在实际开发中，特别是大数据量时，推荐使用EXISTS关键字</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n609" mdtype="fences">SELECT * FROM emp WHERE EXISTS(SELECT 1);-- 全表输出
SELECT * FROM emp WHERE EXISTS(SELECT * FROM emp);-- 全表输出
-- 查询公司是否有大于60岁的员工，有则输出
SELECT * FROM emp a WHERE EXISTS(SELECT * FROM emp b WHERE a.age &gt; 60);-- 输出&gt;60岁
SELECT * FROM emp WHERE EXISTS(SELECT * FROM emp WHERE age &gt; 60);-- 全表输出
-- 查询有所属部门的员工信息
SELECT * FROM emp a WHERE EXISTS(SELECT * FROM dept b WHERE a.dept_id = b.deptid);
SELECT * FROM emp a WHERE dept_id IN(SELECT deptid FROM dept b WHERE a.dept_id = b.deptid);

</pre><h2><a name='header-n610' class='md-header-anchor '></a>33. 自关联查询</h2><ul><li>MySQL有时在信息查询时需要进行对表自身进行关联查询，即一张表自己和自己关联，一张表当成多张表来用。</li><li>注意自关联时表必须给表起别名。</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n616" mdtype="fences">SELECT 字段列表 FROM 表1 a , 表1 b WHERE 条件;
SELECT 字段列表 FROM 表1 a [LEFT] JOIN 表1 b ON 条件;

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n617" mdtype="fences" style="break-inside: unset;">-- 创建自关联约束
CREATE TABLE tablename(
    eid INT PRIMARY KEY ,
    ename VARCHAR(20),
    manager_id INT,-- 外键列
	FOREIGN KEY (manager_id) REFERENCES tablename (eid)  -- 添加自关联约束
);
-- 添加数据
INSERT INTO tablename VALUES(1,'name1',NULL);
INSERT INTO tablename VALUES(2,'name2',1);
INSERT INTO tablename VALUES(3,'name3',2);
INSERT INTO tablename VALUES(4,'name4',2);
INSERT INTO tablename VALUES(5,'name5',1);
INSERT INTO tablename VALUES(6,'name6',5);
INSERT INTO tablename VALUES(7,'name7',5);
INSERT INTO tablename VALUES(8,'name8',1);
INSERT INTO tablename VALUES(9,'name9',8);
INSERT INTO tablename VALUES(10,'name10',8);

</pre><ul><li>关联查询</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n621" mdtype="fences" style="break-inside: unset;">-- 1.查询每个人及上级信息
SELECT * FROM tablename a, tablename b;
SELECT * FROM tablename a, tablename b WHERE a.manager_id = b.eid;-- 必须起别名
SELECT a.ename AS '下级',b.ename AS '所属上级' FROM tablename a, tablename b WHERE a.manager_id = b.eid;-- 必须起别名
SELECT a.ename AS '下级',b.ename AS '所属上级' FROM tablename a JOIN tablename b ON a.manager_id = b.eid;-- 必须起别名

-- 2.查询所有人物及上级，无上级为null
SELECT a.ename AS '下级',b.ename AS '所属上级' FROM tablename a LEFT JOIN tablename b ON a.manager_id = b.eid;-- 必须起别名

-- 3.查询所有人物及上级，上上级，上上上级
SELECT a.ename AS '下级',b.ename AS '上级',c.ename AS '上上级' FROM tablename a LEFT JOIN tablename b ON a.manager_id = b.eid LEFT JOIN tablename c ON b.manager_id = c.eid;-- 必须起别名

SELECT a.ename AS '下级',b.ename AS '上级',c.ename AS '上上级',d.ename AS '上上上级' FROM tablename a LEFT JOIN tablename b ON a.manager_id = b.eid LEFT JOIN tablename c ON b.manager_id = c.eid LEFT JOIN tablename d ON c.manager_id = d.eid;-- 必须起别名

</pre><p>&nbsp;</p><hr /><h1><a name='header-n624' class='md-header-anchor '></a>COMMENT的使用介绍</h1><hr /><blockquote><p><font color=red><strong>作用：为字段或列添加注释。</strong></font></p></blockquote><hr /><h2><a name='header-n629' class='md-header-anchor '></a>1. 创建表时为字段添加注释</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n630" mdtype="fences">CREATE TABLE emp(
    emp_id INT PRIMARY KEY AUTO_INCREMENT COMMENT '编号',
    emp_name CHAR(20) NOT NULL DEFAULT '' COMMENT '姓名',
    salary DECIMAL(10,2) NOT NULL DEFAULT 0 COMMENT '工资',
    department CHAR(20) NOT NULL DEFAULT '' COMMENT '部门'
);
</pre><hr /><h2><a name='header-n632' class='md-header-anchor '></a>2. 创建表后为字段添加注释</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n633" mdtype="fences">ALTER TABLE emp CHANGE COLUMN department department CHAR(20) NOT NULL DEFAULT '' COMMENT '部门';
</pre><hr /><h2><a name='header-n635' class='md-header-anchor '></a>3. 查看表中所有字段的注释</h2><ul><li><strong>方式1</strong></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n639" mdtype="fences">show full columns from tablename;
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n640" mdtype="fences">SHOW FULL COLUMNS FROM emp;
</pre><p><img src='https://img-blog.csdnimg.cn/79e68a76ccc5455fb028c01b63291983.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><ul><li><strong>方式2</strong></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n645" mdtype="fences">SELECT * FROM COLUMNS WHERE TABLE_SCHEMA='dbname' AND TABLE_NAME='tablename';
</pre><p><img src='https://img-blog.csdnimg.cn/e8d0243dd6fb497e9da3eb329f45086d.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><hr /><h2><a name='header-n648' class='md-header-anchor '></a>4. 创建表时为表添加注释</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n649" mdtype="fences">CREATE TABLE test(
    field_name INT
)COMMENT="注释内容";
</pre><hr /><h2><a name='header-n651' class='md-header-anchor '></a>5. 创建表后为表添加注释</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n652" mdtype="fences">alter table tablename comment '表注释内容';
</pre><hr /><h2><a name='header-n654' class='md-header-anchor '></a>6. 查看表注释</h2><ul><li><strong>方式1</strong></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n658" mdtype="fences">show create table tablename;
</pre><p><img src='https://img-blog.csdnimg.cn/3e853bf827464ce2acba99708cf8b2d8.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><ul><li><strong>方式2</strong></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n663" mdtype="fences">USE information_schema;
SELECT * FROM TABLES WHERE TABLE_SCHEMA='dbname' AND TABLE_NAME='tablename';
</pre><p><img src='https://img-blog.csdnimg.cn/85f96cf3d84043c0874f4a9aba63efd8.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><hr /><p><code>——————END-2022-06-11——————</code></p><hr /><p>﻿@<a href='%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86'>TOC</a></p><h1><a name='header-n669' class='md-header-anchor '></a>视图</h1><h2><a name='header-n670' class='md-header-anchor '></a>1. 视图</h2><p>&nbsp;</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n672" mdtype="fences">1. 视图（view）是一个虚拟表，非真实存在，	
	其本质是根据SQL语句获取动态的数据集，并为其命名，
	用户使用时只需使用视图名称即可获取结果集，并可以将其当作表来使用。
2. 数据库中只存放了视图的定义，而并没有存放视图中的数据。
	这些数据存放在原来的表中。
3. 使用视图查询数据时，数据库系统会从原来的表中取出对应的数据。
	因此，视图中的数据是依赖于原来的表中的数据的。
	一旦表中的数据发生改变，显示在视图中的数据也会发生改变。
</pre><p><strong>视图的作用</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n674" mdtype="fences">1. 简化代码，可以把重复使用的查询封装成视图重复使用，
	同时可以使复杂的查询易于理解和使用。
2. 安全原因，如果一张表中有很多数据，很多信息不希望让所有人看到，
	此时可以使用视图，如：社会保险基金表，可以用视图只显示姓名，地址，
	而不显示社会保险号和工资数等，
	可以对不同的用户，设定不同的视图。
</pre><h2><a name='header-n675' class='md-header-anchor '></a>2. 视图创建</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n676" mdtype="fences" style="break-inside: unset;">CREATE [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]
 
VIEW view_name [(column_list)]
 
AS select_statement

[WITH [CASCADED | LOCAL] CHECK OPTION]

参数说明：
 （1）algorithm：可选项，表示视图选择的算法。
 （2）view_name ：表示要创建的视图名称。
 （3）column_list：可选项，指定视图中各个属性的名词，默认情况下与SELECT语句中的查询的属性相同。
 （4）select_statement：表示一个完整的查询语句，将查询记录导入视图中。
 （5）[with [cascaded | local] check option]：可选项，表示更新视图时要保证在该视图的权限范围之内。
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n677" mdtype="fences">CREATE TABLE dept(
   deptno INT PRIMARY KEY,
   dname VARCHAR(20),
   loc VARCHAR(20)
);

INSERT INTO dept VALUES(10, '教研部','北京'),
(20, '学工部','上海'),
(30, '销售部','广州'),
(40, '财务部','武汉');
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n678" mdtype="fences">-- 创建视图
CREATE OR REPLACE VIEW view_dept
AS 
SELECT deptno,dname FROM dept; 

-- 查看视图
SHOW TABLES;
SHOW FULL TABLES;
SELECT * FROM view_dept;
</pre><h2><a name='header-n679' class='md-header-anchor '></a>3. 修改视图</h2><ul><li>修改视图是指修改数据库中已存在的表的定义。 </li><li>MySQL中通过CREATE OR REPLACE VIEW语句和ALTER VIEW语句来修改视图。</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n685" mdtype="fences">ALTER VIEW 视图名 AS select语句
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n686" mdtype="fences">ALTER VIEW view_dept
AS 
SELECT a.deptno,a.dname FROM dept a, emp b WHERE a.deptno = b.deptno;
</pre><h2><a name='header-n687' class='md-header-anchor '></a>4. 视图更新</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n688" mdtype="fences" style="break-inside: unset;">对于可更新的视图，在视图中的行和基表中的行之间必须具有一对一的关系。
如果视图包含下述结构中的任何一种，那么它就是不可更新的：
聚合函数（SUM(), MIN(), MAX(), COUNT()等）
DISTINCT
GROUP BY
HAVING
UNION或UNION ALL
位于选择列表中的子查询
JOIN
FROM子句中的不可更新视图
WHERE子句中的子查询，引用FROM子句中的表。
仅引用文字值（在该情况下，没有要更新的基本表）

一般情况下，最好将视图作为查询数据的虚拟表，而不要通过视图更新数据。
因为，使用视图更新数据时，如果没有全面考虑在视图中更新数据的限制，就可能会造成数据更新失败。
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n689" mdtype="fences" style="break-inside: unset;"> ---------更新视图-------
CREATE OR REPLACE VIEW view1
AS 
SELECT ename,job FROM emp;

SELECT * FROM view1;

UPDATE view1 SET ename = 'xx' WHERE ename = 'yy';  -- 可以修改

SELECT * FROM view;

INSERT INTO view1 VALUES('aa','bb');  -- 不可以插入，不符合插入列

 ----------视图包含聚合函数不可更新--------------
CREATE OR REPLACE VIEW view2
AS 
SELECT COUNT(*) cnt FROM emp;
 
INSERT INTO view2 VALUES(100);
UPDATE view2 SET cnt = 100; 

 ----------视图包含distinct不可更新---------
CREATE OR REPLACE VIEW view3
AS 
SELECT DISTINCT job FROM emp;-- 去重
 
INSERT INTO view3 VALUES('财务');
 
 ----------视图包含goup by、having不可更新------------------
 
CREATE OR REPLACE VIEW view4
AS 
SELECT deptno ,COUNT(*) cnt FROM emp GROUP BY deptno HAVING  cnt &gt; 2;
 
INSERT INTO view4 VALUES(30,100);

 ----------------视图包含union或者union all不可更新----------------
CREATE OR REPLACE VIEW view5
AS 
SELECT empno,ename FROM emp WHERE empno &lt;= 1005
UNION 
SELECT empno,ename FROM emp WHERE empno &gt; 1005;
 
INSERT INTO view5 VALUES(1015,'xx');

 -------------------视图包含子查询不可更新--------------------
CREATE OR REPLACE VIEW view6
AS 
SELECT empno,ename,sal FROM emp WHERE sal = (SELECT MAX(sal) FROM emp);
 
INSERT INTO view6 VALUES(1015,'xx',30000);

 ----------------------视图包含join不可更新-----------------
CREATE OR REPLACE VIEW view7
AS 
SELECT dname,ename FROM emp a JOIN  dept b  ON a.deptno = b.deptno;
 
INSERT INTO view7 (dname,ename) VALUES('行政部','xx',);
 
 --------------------视图包含常量文字值不可更新-------------------
CREATE OR REPLACE VIEW view8
AS 
SELECT '行政部' dname,'xx'  ename;
 
INSERT INTO view8 VALUES('行政部','xx');

</pre><h2><a name='header-n690' class='md-header-anchor '></a>5. 重命名/删除视图</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n691" mdtype="fences">重命名视图：
rename table 视图名 to 新视图名; 

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n692" mdtype="fences">删除视图：
drop view 视图名[,视图名…];
删除视图时，只能删除视图的定义，不会删除数据。

</pre><hr /><p>﻿@<a href='%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86'>TOC</a></p><h1><a name='header-n695' class='md-header-anchor '></a>函数</h1><h2><a name='header-n696' class='md-header-anchor '></a>1. 聚合函数</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n697" mdtype="fences">在MySQL中，聚合函数主要有count,sum,min,max,avg等
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n698" mdtype="fences">group_concat(）函数实现行的合并：
格式：
GROUP_CONCAT([DISTINCT] 字段名 [ORDER BY 排序字段 ASC/DESC] [SEPARATOR '分隔符'])

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n699" mdtype="fences">说明：
（1）使用distinct可以排除重复值；
（2）如果需要对结果中的值进行排序，可以使用order by子句；
（3）separator是一个字符串值，默认为逗号。
</pre><p><strong>应用</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n701" mdtype="fences" style="break-inside: unset;">CREATE TABLE emp(
    emp_id INT PRIMARY KEY AUTO_INCREMENT COMMENT '编号',
    emp_name CHAR(20) NOT NULL DEFAULT '' COMMENT '姓名',
    salary DECIMAL(10,2) NOT NULL DEFAULT 0 COMMENT '工资',
    department CHAR(20) NOT NULL DEFAULT '' COMMENT '部门'
);
INSERT INTO emp(emp_name,salary,department) 
VALUES('name1',5000,'财务部'),('name2',5800,'财务部'),('name3',6200,'财务部'),('name4',5700,'人事部'),
('name5',6700,'人事部'),('name6',5200,'人事部'),('name7',7500,'销售部'),('name8',7200,'销售部'),
('name9',7800,'销售部');

-- 将所有员工的名字合并成一行 
SELECT GROUP_CONCAT(emp_name) FROM emp;
SELECT GROUP_CONCAT(emp_name) AS emp_name FROM emp;
SELECT GROUP_CONCAT(emp_name SEPARATOR ' [分隔符] ') AS emp_name FROM emp;

-- 指定分隔符合并 
-- 按部门分组
SELECT department,GROUP_CONCAT(emp_name SEPARATOR ';' ) FROM emp GROUP BY department;

-- 指定排序方式和分隔符 
-- 人名按薪资降序排列 指定分隔符必须放在最后
SELECT department,GROUP_CONCAT(emp_name ORDER BY salary DESC SEPARATOR ';' ) AS name FROM emp GROUP BY department;
</pre><h2><a name='header-n702' class='md-header-anchor '></a>2. 数学函数</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n703" mdtype="fences" style="break-inside: unset;">ABS(X)		返回x的绝对值	
CEIL(X)		返回大于或等于 X 的最小整数
FLOOR(X)	返回小于或等于 X 的最大整数
GREATEST(expr1, expr2, expr3, ...)		返回列表中的最大值
LEAST(expr1, expr2, expr3, ...)			返回列表中的最小值
MAX(expression)		返回字段 expression 中的最大值
MIN(expression)		返回字段 expression 中的最小值
MOD(X,Y)	返回 X 除以 Y 以后的余数　	
PI()	返回圆周率(3.141593）
POW(X,Y)	返回 X 的 Y 次方　
RAND()	返回 0 到 1 的随机数
ROUND(X)	返回离 X 最近的整数（遵循四舍五入）
ROUND(X,Y)	返回指定位数的小数（遵循四舍五入）
TRUNCATE(X,Y)	返回数值 X 保留到小数点后 Y 位的值（与 ROUND 最大的区别是不会进行四舍五入）
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n704" mdtype="fences">SELECT LEAST(1,2,3);-- 1
SELECT TRUNCATE(3.5415,3);-- 3.541
</pre><h2><a name='header-n705' class='md-header-anchor '></a>3. 字符串函数</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n706" mdtype="fences" style="break-inside: unset;">CHAR_LENGTH(s)	返回字符串 s 的字符数
CHARACTER_LENGTH(s)		返回字符串 s 的字符数	
CONCAT(s1,s2...sn)		字符串 s1,s2 等多个字符串合并为一个字符串
CONCAT_WS(X, s1,s2...sn)	同 CONCAT(s1,s2,...) 函数，但是每个字符串之间要加上 x，x 可以是分隔符
FIELD(s,s1,s2...)	返回第一个字符串 s 在字符串列表(s1,s2...)中的位置
LTRIM(s)	去掉字符串 s 开始处的空格
MID(s,n,len)	从字符串 s 的 n 位置截取长度为 len 的子字符串，同 SUBSTRING(s,n,len)
POSITION(s1 IN s)	从字符串 s 中获取 s1 的开始位置
REPLACE(s,s1,s2)	将字符串 s2 替代字符串 s 中的字符串 s1
REVERSE(s)	将字符串s的顺序反过来
RIGHT(s,n)	返回字符串 s 的后 n 个字符
RTRIM(s)	去掉字符串 s 结尾处的空格
STRCMP(s1,s2)	比较字符串 s1 和 s2，如果 s1 与 s2 相等返回 0 ，如果 s1&gt;s2 返回 1，如果 s1&lt;s2 返回 -1
SUBSTR(s, START, LENGTH)	从字符串 s 的 START 位置截取长度为 LENGTH 的子字符串
SUBSTRING(s, START, LENGTH)		从字符串 s 的 START 位置截取长度为 LENGTH 的子字符串
TRIM(s)	去掉字符串 s 开始和结尾处的空格
UCASE(s)	将字符串转换为大写
UPPER(s)	将字符串转换为大写
LCASE(s)	将字符串 s 的所有字母变成小写字母
LOWER(s)	将字符串 s 的所有字母变成小写字母
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n707" mdtype="fences">SELECT REPLACE('abc','a','x'); -- xbc
SELECT FIELD("c", "a", "b", "c", "d", "e"); -- 3
SELECT CONCAT_WS("-", "SQL", "Tutorial", "is", "fun!")AS ConcatenatedString; -- SQL-Tutorial-is-fun!
</pre><h2><a name='header-n708' class='md-header-anchor '></a>4. 日期函数</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n709" mdtype="fences">UNIX_TIMESTAMP()	返回从1970-01-01 00:00:00到当前毫秒值

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n710" mdtype="fences">UNIX_TIMESTAMP(DATE_STRING)		将制定日期转为毫秒值时间戳
SELECT UNIX_TIMESTAMP('2011-12-07 13:01:03');

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n711" mdtype="fences">FROM_UNIXTIME(BIGINT UNIXTIME[, STRING FORMAT])	将毫秒值时间戳转为指定格式日期
SELECT FROM_UNIXTIME(1598079966,'%Y-%m-%d %H:%i:%s'); (1598079966,'%Y-%m-%d %H:%i:%s'); --&gt; 2020-08-22 15-06-06

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n712" mdtype="fences">CURDATE()	返回当前日期	SELECT CURDATE();-&gt; 2018-09-19
CURRENT_DATE()	返回当前日期	SELECT CURRENT_DATE();-&gt; 2018-09-19

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n713" mdtype="fences">CURRENT_TIME()	返回当前时间	
SELECT CURRENT_TIME();-&gt; 19:59:02
CURTIME()	返回当前时间	
SELECT CURTIME();-&gt; 19:59:02

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n714" mdtype="fences">CURRENT_TIMESTAMP()	返回当前日期和时间
SELECT CURRENT_TIMESTAMP()-&gt; 2018-09-19 20:57:43

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n715" mdtype="fences">DATE()	从日期或日期时间表达式中提取日期值
SELECT DATE("2017-06-15");-&gt; 2017-06-15

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n716" mdtype="fences">DATEDIFF(d1,d2)	计算日期 d1-&gt;d2 之间相隔的天数
SELECT DATEDIFF('2001-01-01','2001-02-02')-&gt; -32

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n717" mdtype="fences">TIMEDIFF(time1, time2)	计算时间差值
SELECT TIMEDIFF("13:10:11", "13:10:10");-&gt; 00:00:01

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n718" mdtype="fences">DATE_FORMAT(d,f)	按表达式 f的要求显示日期 d
SELECT DATE_FORMAT('2011-11-11 11:11:11','%Y-%m-%d %r')-&gt; 2011-11-11 11:11:11 AM

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n719" mdtype="fences">STR_TO_DATE(STRING, format_mask)	将字符串转变为日期
SELECT STR_TO_DATE("August 10 2017", "%M %d %Y");-&gt; 2017-08-10

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n720" mdtype="fences">DATE_SUB(DATE,INTERVAL expr TYPE)	函数从日期减去指定的时间间隔。
-- Orders 表中 OrderDate 字段减去 2 天：
SELECT OrderId,DATE_SUB(OrderDate,INTERVAL 2 DAY) AS OrderPayDate FROM Orders

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n721" mdtype="fences" style="break-inside: unset;">ADDDATE/DATE_ADD(d，INTERVAL expr TYPE)	计算起始日期 d 加上一个时间段后的日期
type 值：
		MICROSECOND
		SECOND
		MINUTE
		HOUR
		DAY
		WEEK
		MONTH
		QUARTER
		YEAR
		DAY_MINUTE
		DAY_HOUR
		YEAR_MONTH

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n722" mdtype="fences">SELECT DATE_ADD("2017-06-15 09:34:21", INTERVAL 15 MINUTE);-&gt; 2017-06-15 09:49:21

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n723" mdtype="fences" style="break-inside: unset;">DATE_ADD(d，INTERVAL expr TYPE)	 计算起始日期 d 加上一个时间段后的日期
type的值：
		SECOND_MICROSECOND
		MINUTE_MICROSECOND
		MINUTE_SECOND
		HOUR_MICROSECOND
		HOUR_SECOND
		HOUR_MINUTE
		DAY_MICROSECOND
		DAY_SECOND
		DAY_MINUTE
		DAY_HOUR
		YEAR_MONTH

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n724" mdtype="fences">SELECT DATE_ADD("2017-06-15 09:34:21", INTERVAL -3 HOUR);-&gt;2017-06-15 06:34:21

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n725" mdtype="fences">EXTRACT(TYPE FROM d) 	从日期 d 中获取指定的值，type 指定返回的值。
type可取值为：
		MICROSECOND
		SECOND
		MINUTE
		HOUR
		...
		
SELECT EXTRACT(MINUTE FROM '2011-11-11 11:11:11'); -&gt; 11

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n726" mdtype="fences">LAST_DAY(d)	返回给给定日期的那一月份的最后一天
SELECT LAST_DAY("2017-06-20");-&gt; 2017-06-30

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n727" mdtype="fences">MAKEDATE(YEAR, DAY-of-YEAR)	基于给定参数年份 YEAR 和所在年中的天数序号 DAY-of-YEAR 返回一个日期
SELECT MAKEDATE(2017, 3);-&gt; 2017-01-03

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n728" mdtype="fences" style="break-inside: unset;">YEAR(d)		返回年份	SELECT YEAR("2017-06-15");-&gt; 2017
MONTH(d)	返回日期d中的月份值，1 到 12	SELECT MONTH('2011-11-11 11:11:11');-&gt;11
DAY(d)		返回日期值 d 的日期部分	SELECT DAY("2017-06-15");-&gt; 15
HOUR(t)		返回 t 中的小时值	SELECT HOUR('1:2:3');-&gt; 1
MINUTE(t)	返回 t 中的分钟值	SELECT MINUTE('1:2:3');-&gt; 2
SECOND(t)	返回 t 中的秒钟值	SELECT SECOND('1:2:3');-&gt; 3
QUARTER(d)	返回日期d是第几季节，返回 1 到 4	SELECT QUARTER('2011-11-11 11:11:11');-&gt; 4
MONTHNAME(d)	返回日期当中的月份名称，如 November	SELECT MONTHNAME('2011-11-11 11:11:11');-&gt; November
MONTH(d)		返回日期d中的月份值，1 到 12	SELECT MONTH('2011-11-11 11:11:11');-&gt;11
DAYNAME(d)		返回日期 d 是星期几，如 Monday,Tuesday	SELECT DAYNAME('2011-11-11 11:11:11');-&gt;Friday
DAYOFMONTH(d)	计算日期 d 是本月的第几天	SELECT DAYOFMONTH('2011-11-11 11:11:11');-&gt;11
DAYOFWEEK(d)	日期 d 今天是星期几，1 星期日，2 星期一，以此类推	SELECT DAYOFWEEK('2011-11-11 11:11:11');-&gt;6
DAYOFYEAR(d)	计算日期 d 是本年的第几天	SELECT DAYOFYEAR('2011-11-11 11:11:11');-&gt;315
WEEK(d)			计算日期 d 是本年的第几个星期，范围是 0 到 53	SELECT WEEK('2011-11-11 11:11:11');-&gt; 45
WEEKDAY(d)		日期 d 是星期几，0 表示星期一，1 表示星期二		SELECT WEEKDAY("2017-06-15");-&gt; 3
WEEKOFYEAR(d)	计算日期 d 是本年的第几个星期，范围是 0 到 53	SELECT WEEKOFYEAR('2011-11-11 11:11:11');-&gt; 45
YEARWEEK(DATE, MODE)	返回年份及第几周（0到53），mode 中 0 表示周天，1表示周一，以此类推	SELECT YEARWEEK("2017-06-15");-&gt; 201724
NOW()					返回当前日期和时间	SELECT NOW();-&gt; 2018-09-19 20:57:43

</pre><h2><a name='header-n729' class='md-header-anchor '></a>5. 控制流函数</h2><p><strong>if逻辑判断语句</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n731" mdtype="fences">IF(expr,v1,v2)	如果表达式 expr 成立，返回结果 v1；否则，返回结果 v2。
SELECT IF(1 &gt; 0,'正确','错误');-&gt;正确
IFNULL(v1,v2)	如果 v1 的值不为 NULL，则返回 v1，否则返回 v2。
SELECT IFNULL(NULL,'Hello Word');-&gt;Hello Word
ISNULL(expression)	判断表达式是否为null	SELECT ISNULL(NULL);-&gt;1

</pre><p><strong>case-when语句</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n733" mdtype="fences">CASE expression
    WHEN condition1 THEN result1
    WHEN condition2 THEN result2
   ...
    WHEN conditionN THEN resultN
    ELSE result
END

CASE 表示函数开始，END 表示函数结束。
如果 condition1 成立，则返回 result1, 
如果 condition2 成立，则返回 result2，当全部不成立则返回 result，
而当有一个成立之后，后面的就不执行了。

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n734" mdtype="fences">SELECT CASE 100 WHEN 50 THEN 'tom' WHEN 100 THEN 'mary'ELSE 'tim' END AS info;

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n735" mdtype="fences" style="break-inside: unset;">CREATE TABLE orders(
 oid INT PRIMARY KEY, -- 订单id
 price DOUBLE, -- 订单价格
 payType INT -- 支付类型(1:微信支付 2:支付宝支付 3:银行卡支付 4：其他)
);

INSERT INTO orders VALUES(1,1200,1);
INSERT INTO orders VALUES(2,1000,2);
INSERT INTO orders VALUES(3,200,3);
INSERT INTO orders VALUES(4,3000,1);
INSERT INTO orders VALUES(5,1500,2);

SELECT * ,
CASE 
  WHEN payType=1 THEN '微信支付' 
    WHEN payType=2 THEN '支付宝支付' 
    WHEN payType=3 THEN '银行卡支付' 
    ELSE '其他支付方式' 
END  AS payTypeStr
FROM orders;

SELECT *  ,
CASE payType
  WHEN 1 THEN '微信支付' 
    WHEN 2 THEN '支付宝支付' 
    WHEN 3 THEN '银行卡支付' 
    ELSE '其他支付方式' 
END  AS payTypeStr
FROM orders;

</pre><h2><a name='header-n736' class='md-header-anchor '></a>6. 窗口函数</h2><p><strong>语法结构</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n738" mdtype="fences" style="break-inside: unset;">window_function ( expr ) OVER ( 
  PARTITION BY ... 
  ORDER BY ... 
  frame_clause 
)


window_function 是窗口函数的名称；
expr 是参数，有些函数不需要参数；
OVER子句包含三个选项：
分区（PARTITION BY）
PARTITION BY选项用于将数据行拆分成多个分区（组），它的作用类似于GROUP BY分组。
如果省略了 PARTITION BY，所有的数据作为一个组进行计算
排序（ORDER BY）
OVER 子句中的ORDER BY选项用于指定分区内的排序方式，与 ORDER BY 子句的作用类似。
窗口大小（frame_clause）。
frame_clause选项用于在当前分区内指定一个计算窗口，即一个与当前行相关的数据子集。

</pre><p><strong>序号函数</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n740" mdtype="fences">ROW_NUMBER()、RANK()、DENSE_RANK()，可以用来实现分组排序，并添加序号

row_number()|rank()|dense_rank() over ( 
  PARTITION BY ... 
  ORDER BY ... 
) 

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n741" mdtype="fences" style="break-inside: unset;">CREATE TABLE employee( 
   dname VARCHAR(20), -- 部门名 
   eid VARCHAR(20), -- 员工编号
   ename VARCHAR(20), -- 员工姓名
   hiredate DATE, -- 入职日期 
   salary DOUBLE -- 薪资
); 

INSERT INTO employee VALUES('研发部','1001','name1','2021-11-01',3000);
INSERT INTO employee VALUES('研发部','1002','name2','2021-11-02',5000);
INSERT INTO employee VALUES('研发部','1003','name3','2021-11-03',7000);
INSERT INTO employee VALUES('研发部','1004','name4','2021-11-04',7000);
INSERT INTO employee VALUES('研发部','1005','name5','2021-11-05',4000);
INSERT INTO employee VALUES('研发部','1006','name6','2021-11-06',4000);
 
INSERT INTO employee VALUES('销售部','1007','name7','2021-11-01',2000);
INSERT INTO employee VALUES('销售部','1008','name8','2021-11-02',5000);
INSERT INTO employee VALUES('销售部','1009','name9','2021-11-03',3000);
INSERT INTO employee VALUES('销售部','1010','name0','2021-11-05',9000);

</pre><p><img src='https://img-blog.csdnimg.cn/d0ade3c640304787aeef32881712aa6b.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n743" mdtype="fences">-- 对每个部门的员工按照薪资排序，并给出排名
SELECT 
dname,
ename,
salary,
row_number() over(PARTITION BY dname ORDER BY salary DESC) AS rn1,
dense_rank() over(PARTITION BY dname ORDER BY salary DESC) AS rn2,
rank() over(PARTITION BY dname ORDER BY salary DESC) AS rn3   
FROM employee;

</pre><p><img src='https://img-blog.csdnimg.cn/362e103e8bd24936ab777caa46fb26d7.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n745" mdtype="fences">-- 对所有员工进行全局排序（不分组）
SELECT 
     dname,
     ename,
     salary,
     dense_rank() over(ORDER BY salary DESC)  AS rn
FROM employee;

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n746" mdtype="fences" style="break-inside: unset;">-- 求出每个部门薪资排在前三名的员工-分组求TOPN
SELECT 
* 
FROM 
(
    SELECT 
     dname,
     ename,
     salary,
     dense_rank() over(PARTITION BY dname ORDER BY salary DESC)  AS rn
    FROM employee
)t
WHERE t.rn &lt;= 1;

</pre><p><img src='https://img-blog.csdnimg.cn/c7e95bfbd6d14fd0bb136c00892a4d1c.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p><strong>开窗聚合函数</strong></p><ul><li>在窗口中每条记录动态地应用聚合函数（SUM()、AVG()、MAX()、MIN()、COUNT()），可以动态计算在指定的窗口内的各种聚合函数值。</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n752" mdtype="fences">SELECT  
 dname,
 ename,
 salary,
 hiredate,
 SUM(salary) over(PARTITION BY dname ORDER BY hiredate) AS pv1 
FROM employee;

</pre><p><img src='https://img-blog.csdnimg.cn/c6c80199d6ca43ffa67fc638baa81f96.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n754" mdtype="fences">SELECT  
 dname,
 ename,
 salary,
 hiredate,
SUM(salary) over(PARTITION BY dname) AS pv3
FROM employee;-- 如果没有order  by排序语句  默认把分组内的所有数据进行sum操作

</pre><p><img src='https://img-blog.csdnimg.cn/f7142e9a4a0047668e3cb0be71d7c7b8.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n756" mdtype="fences">-- 向上三行加到当前行
SELECT  
 dname,
 ename,
 salary,
 SUM(salary) over(PARTITION BY dname ORDER BY hiredate ROWS BETWEEN 3 preceding AND current ROW) AS c1 
FROM employee;

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n757" mdtype="fences">-- 向上三行 向下一行
SELECT  
 dname,
 ename,
 salary,
 SUM(salary) over(PARTITION BY dname ORDER BY hiredate   ROWS BETWEEN 3 preceding AND 1 following) AS c1 
FROM employee;

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n758" mdtype="fences">-- 当前行加到最后
SELECT  
 dname,
 ename,
 salary,
 SUM(salary) over(PARTITION BY dname ORDER BY hiredate   ROWS BETWEEN current ROW AND unbounded following) AS c1 
FROM employee;

</pre><p><strong>分布函数</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n760" mdtype="fences">CUME_DIST：分组内小于、等于当前rank值的行数 / 分组内总行数。
PERCENT_RANK：每行按照公式(rank-1) / (rows-1)进行计算。其中，rank为RANK()函数产生的序号，rows为当前窗口的记录总行数

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n761" mdtype="fences" style="break-inside: unset;">SELECT  
 dname,
 ename,
 salary,
 cume_dist() over(ORDER BY salary) AS rn1, -- 没有partition语句 所有的数据位于一组
 cume_dist() over(PARTITION BY dname ORDER BY salary) AS rn2 
FROM employee;

rn1: 没有partition,所有数据均为1组，总行数为12，
      第一行：小于等于3000的行数为3，因此，3/12=0.25
      第二行：小于等于4000的行数为5，因此，5/12=0.4166666666666667
rn2: 按照部门分组，dname='研发部'的行数为6,
      第一行：研发部小于等于3000的行数为1，因此，1/6=0.16666666666666666

</pre><p><img src='https://img-blog.csdnimg.cn/6035b7c07a1e4dc186ad2b8893b548b5.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n763" mdtype="fences">SELECT 
 dname,
 ename,
 salary,
 rank() over(PARTITION BY dname ORDER BY salary DESC ) AS rn1,
 percent_rank() over(PARTITION BY dname ORDER BY salary DESC ) AS rn2
FROM employee;

rn2:
 第一行: (1 - 1) / (6 - 1) = 0
 第二行: (1 - 1) / (6 - 1) = 0
 第三行: (3 - 1) / (6 - 1) = 0.4

</pre><p><img src='https://img-blog.csdnimg.cn/2b01f1efd3544ebf80142bd279cd6e11.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' />
<strong>前后函数</strong></p><ul><li>返回位于当前行的前n行（LAG(expr,n)）或后n行（LEAD(expr,n)）的expr的值。</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n768" mdtype="fences" style="break-inside: unset;">SELECT 
 dname,
 ename,
 salary,
 hiredate,
 lag(hiredate,1,'2000-01-01') over(PARTITION BY dname ORDER BY hiredate) AS last_1_time,
 lag(hiredate,2) over(PARTITION BY dname ORDER BY hiredate) AS last_2_time 
FROM employee;

last_1_time: 指定了往上第1行的值，default为'2000-01-01'  
   第一行，往上1行为null,因此取默认值 '2000-01-01'
   第二行，往上1行值为第一行值，2021-11-01 
   第三行，往上1行值为第二行值，2021-11-02 
 last_2_time: 指定了往上第2行的值，为指定默认值
   第一行，往上2行为null
   第二行，往上2行为null
   第四行，往上2行为第二行值，2021-11-01 
   第七行，往上2行为第五行值，2021-11-02 

</pre><p><img src='https://img-blog.csdnimg.cn/abda4a01aed449b5a861764dc7971250.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n770" mdtype="fences">SELECT 
 dname,
 ename,
 salary,
 hiredate,
 lead(hiredate,1,'2000-01-01') over(PARTITION BY dname ORDER BY hiredate) AS last_1_time,
 lead(hiredate,2) over(PARTITION BY dname ORDER BY hiredate) AS last_2_time 
FROM employee;

</pre><p><img src='https://img-blog.csdnimg.cn/a8f7327601084d508c982c1fc9704d6b.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p><strong>头尾函数</strong></p><ul><li>返回第一个（FIRST_VALUE(expr)）或最后一个（LAST_VALUE(expr)）expr的值。</li><li>如果不指定ORDER BY，则进行排序混乱，会出现错误的结果。</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n778" mdtype="fences">SELECT
  dname,
  ename,
  hiredate,
  salary,
  first_value(salary) over(PARTITION BY dname ORDER BY hiredate) AS FIRST,-- 到目前为止的第一个
  last_value(salary) over(PARTITION BY dname ORDER BY  hiredate) AS LAST -- 到目前为止的最后一个
FROM  employee;

</pre><p><img src='https://img-blog.csdnimg.cn/ee81fcf62c464115a8243e1c474e44aa.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' />
<strong>其他函数</strong></p><ul><li>NTH_VALUE(expr,n)：返回窗口中第n个expr的值。expr可以是表达式，也可以是列名。</li><li>NTILE(n)：将分区中的有序数据分为n个等级，记录等级数。</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n785" mdtype="fences">-- 查询每个部门截止目前薪资排在第二和第三的员工信息
SELECT 
  dname,
  ename,
  hiredate,
  salary,
  nth_value(salary,2) over(PARTITION BY dname ORDER BY hiredate) AS second_score,-- 按照入职日期排序的第二个的薪资
  nth_value(salary,3) over(PARTITION BY dname ORDER BY hiredate) AS third_score
FROM employee;

</pre><p><img src='https://img-blog.csdnimg.cn/43719eb99587403691bf6c931fb5bf92.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n787" mdtype="fences" style="break-inside: unset;">-- 根据入职日期将每个部门的员工分成3组
SELECT 
  dname,
  ename,
  hiredate,
  salary,
ntile(3) over(PARTITION BY dname ORDER BY  hiredate  ) AS nt 
FROM employee;

-- 取出每个部门的第一组员工
SELECT
*
FROM
(
    SELECT 
        dname,
        ename,
        hiredate,
        salary,
    NTILE(3) OVER(PARTITION BY dname ORDER BY  hiredate  ) AS nt 
    FROM employee
)t
WHERE t.nt = 1;

</pre><hr /><hr /><hr /><p>﻿@<a href='%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86'>TOC</a></p><h1><a name='header-n792' class='md-header-anchor '></a>存储过程，触发器，索引，存储引擎</h1><h2><a name='header-n793' class='md-header-anchor '></a>1. 变量定义</h2><p><code>数据准备</code></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n795" mdtype="fences">CREATE TABLE dept(
   deptno INT PRIMARY KEY,
   dname VARCHAR(20),
   loc VARCHAR(20)
);

INSERT INTO dept VALUES(10, '教研部','北京'),
(20, '学工部','上海'),
(30, '销售部','广州'),
(40, '财务部','武汉');
</pre><ul><li>存储过程就是一组SQL语句集，功能强大，可以实现一些比较复杂的逻辑功能。</li><li>速度快，只有首次执行需经过编译和优化步骤，后续被调用可以直接执行。</li></ul><p><code>格式</code></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n802" mdtype="fences">DELIMITER 自定义结束符号
CREATE PROCEDURE 储存名([ IN ,OUT ,INOUT ] 参数名 数据类形...)
BEGIN
  sql语句
END 自定义的结束符合
DELIMITER ;
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n803" mdtype="fences">-- 创建存储过程：
DELIMITER $$
CREATE PROCEDURE proc01()
BEGIN
  SELECT deptno,dname FROM dept; 
END  $$
DELIMITER ;
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n804" mdtype="fences">-- 调用存储过程：
CALL proc01();
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n805" mdtype="fences">-- 删除存储过程：
DROP PROCEDURE [ IF EXISTS ] &lt;过程名&gt;;
DROP PROCEDURE proc01;
</pre><p><strong>变量定义:</strong></p><ul><li><p>局部变量：</p><ol start='' ><li>用户自定义，在begin/end块中有效 。</li><li>声明变量 declare var_name type [default var_value]; </li></ol></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n815" mdtype="fences">-- 创建存储过程：
DELIMITER $$
CREATE PROCEDURE proc02()
BEGIN
    DECLARE var_name01 VARCHAR(20) DEFAULT 'aaa';  -- 定义局部变量
    SET var_name01 = 'zhangsan';  -- 赋值
    SELECT var_name01;-- 输出变量
END $$
DELIMITER ;
-- 调用存储过程
CALL proc02();
</pre><p>&nbsp;</p><ul><li>MySQL中还可以使用 SELECT..INTO 语句为变量赋值。其基本语法如下：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n820" mdtype="fences">SELECT col_name [...] INTO var_name[,...] 
FROM table_name wehre CONDITION 

col_name 参数表示查询的字段名称；
var_name 参数是变量的名称；
table_name 参数指表的名称；
CONDITION 参数指查询条件。
注意：当将查询结果赋值给变量时，该查询语句的返回结果只能是单行单列。
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n821" mdtype="fences">-- 创建存储过程：
DELIMITER $$
CREATE PROCEDURE proc03()
BEGIN
  DECLARE my_dname VARCHAR(20) ;
  SELECT dname INTO my_dname FROM dept WHERE deptno=10;
  SELECT my_dname;
END $$
DELIMITER ;
-- 调用存储过程
CALL proc03();
</pre><ul><li><p>用户变量：</p><ol start='' ><li>用户自定义，当前会话（连接）有效。</li><li>@var_name 不需要提前声明，使用即声明。</li></ol></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n830" mdtype="fences">-- 创建存储过程：
DELIMITER $$
CREATE PROCEDURE proc04()
BEGIN
    SET @var_name01  = 'ZS';
    SELECT @var_name01;
END $$
DELIMITER ;
-- 调用存储过程：
CALL proc04() ;
SELECT @var_name01  ;
</pre><ul><li>系统变量：系统变量又分为全局变量与会话变量。</li><li>全局变量在MYSQL启动的时候由服务器自动将它们初始化为默认值，这些默认值可以通过更改my.ini这个文件来更改。</li><li>会话变量在每次建立一个新的连接的时候，由MYSQL来初始化。MYSQL会将当前所有全局变量的值复制一份。来做为会话变量。</li><li>在建立会话以后，没有手动更改过会话变量与全局变量的值，那所有这些变量的值都是一样的。</li><li>全局变量与会话变量的区别就在于，对全局变量的修改会影响到整个服务器，但是对会话变量的修改，只会影响到当前的会话（也就是当前的数据库连接）。</li><li>有些系统变量的值是可以利用语句来动态进行更改的，但是有些系统变量的值却是只读的，对于那些可以更改的系统变量，我们可以利用set语句进行更改。</li><li>系统变量-全局变量：由系统提供，在整个数据库有效。</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n846" mdtype="fences">@@global.var_name
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n847" mdtype="fences">-- 查看全局变量 
SHOW GLOBAL VARIABLES; 
-- 查看某全局变量 
SELECT @@global.auto_increment_increment; 
-- 修改全局变量的值 
SELECT @@global.sort_buffer_size; 
SET GLOBAL sort_buffer_size = 40000; 
SET @@global.sort_buffer_size = 40000;
</pre><ul><li>系统变量-会话变量：由系统提供，当前会话（连接）有效 。</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n851" mdtype="fences">@@session.var_name
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n852" mdtype="fences">-- 查看会话变量
SHOW SESSION VARIABLES;
-- 查看某会话变量 
SELECT @@session.auto_increment_increment;
-- 修改会话变量的值
SET SESSION sort_buffer_size = 50000; 
SET @@session.sort_buffer_size = 50000 ;
</pre><p><strong>存储过程传参</strong></p><ul><li>存储过程传参-in：</li><li>in 表示传入的参数， 可以传入数值或者变量，即使传入变量，并不会更改变量的值，可以内部更改，仅仅作用在函数范围内。</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n859" mdtype="fences">-- 创建存储过程：
DELIMITER $$
CREATE PROCEDURE dec_param01(IN deptno INT)
BEGIN
        SELECT * FROM dept WHERE dept.deptno = deptno;-- 也可以使用表名.的方式区分
END $$
DELIMITER ;
-- 调用存储过程：
CALL dec_param01(10);
</pre><ul><li>存储过程传参-out：</li><li>out 表示从存储过程内部传值给调用者。</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n865" mdtype="fences">-- 创建存储过程：
DELIMITER $$
CREATE PROCEDURE proc08(IN deptno INT ,OUT out_dname VARCHAR(50) )
BEGIN
  SELECT dname INTO out_dname FROM dept WHERE dept.deptno = deptno;
END $$
DELIMITER ;
-- 调用存储过程：
CALL proc08(10, @o_dname);
SELECT @o_dname;
</pre><ul><li>存储过程传参-inout：</li><li>inout 表示从外部传入的参数经过修改后可以返回的变量，既可以使用传入变量的值也可以修改变量的值（即使函数执行完）。</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n871" mdtype="fences">-- 创建存储过程：
DELIMITER $$
CREATE PROCEDURE proc10(INOUT inout_dname VARCHAR(50))
BEGIN
  SELECT  CONCAT(deptno,"_",dname) INTO inout_dname FROM dept WHERE dname = inout_dname;
END $$
DELIMITER ;
-- 调用存储过程：
SET @inout_dname = '教研部';
CALL proc10(@inout_dname);
SELECT @inout_dname;
</pre><h2><a name='header-n872' class='md-header-anchor '></a>2. 流程控制</h2><p><strong>if</strong></p><ul><li>IF语句包含多个条件判断，根据结果为TRUE、FALSE执行语句。</li></ul><p><code>//格式：</code></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n878" mdtype="fences">IF search_condition_1 THEN statement_list_1
    [ELSEIF search_condition_2 THEN statement_list_2] ...
    [ELSE statement_list_n]
END IF
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n879" mdtype="fences" style="break-inside: unset;">-- 创建存储过程：
DELIMITER $$
CREATE PROCEDURE proc_if(IN score INT)
BEGIN
  IF score &lt; 60 THEN
	  SELECT '不及格';
  ELSEIF  score &lt; 80
      THEN
          SELECT '及格';
  ELSEIF score &gt;= 80 AND score &lt; 90
       THEN 
           SELECT '良好';
  ELSEIF score &gt;= 90 AND score &lt;= 100
       THEN 
           SELECT '优秀';
  ELSE
       SELECT '成绩错误';
  END IF;
END $$
DELIMITER ;
-- 调用存储过程：
CALL proc_if(10);
</pre><p><strong>case</strong></p><p><code>//格式：</code></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n882" mdtype="fences">CASE case_value
    WHEN when_value THEN statement_list
    [WHEN when_value THEN statement_list] ...
    [ELSE statement_list]
END CASE
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n883" mdtype="fences">CASE
    WHEN search_condition THEN statement_list
    [WHEN search_condition THEN statement_list] ...
    [ELSE statement_list]
END CASE
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n884" mdtype="fences" style="break-inside: unset;">-- 创建存储过程：
DELIMITER $$
CREATE PROCEDURE proc_case(IN pay_type INT)
BEGIN
  CASE pay_type
        WHEN  1 
          THEN 
              SELECT '微信支付' ;
        WHEN  2 
		  THEN 
			  SELECT '支付宝支付' ;
        WHEN  3 
          THEN 
              SELECT '银行卡支付';
		ELSE 
		  SELECT '其他方式支付';
    END CASE ;
END $$
DELIMITER ;
-- 调用存储过程：
CALL proc_case(2);
CALL proc_case(4);
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n885" mdtype="fences" style="break-inside: unset;">-- 创建存储过程：
DELIMITER $$
CREATE PROCEDURE proc_case(IN score INT)
BEGIN
  CASE
  WHEN score &lt; 60 
      THEN
          SELECT '不及格';
    WHEN  score &lt; 80
      THEN
          SELECT '及格' ;
    WHEN score &gt;= 80 AND score &lt; 90
       THEN 
           SELECT '良好';
  WHEN score &gt;= 90 AND score &lt;= 100
       THEN 
           SELECT '优秀';
     ELSE
       SELECT '成绩错误';
  END CASE;
END $$
DELIMITER ;
-- 调用存储过程：
CALL proc_case(88);
</pre><p><strong>循环：</strong></p><ol start='' ><li><p>循环是一段在程序中只出现一次,但可能会连续运行多次的代码。</p></li><li><p>循环中的代码会运行特定的次数,或者是运行到特定条件成立时结束循环
3.循环分类：WHILE REPEAT LOOP</p></li><li><p>循环控制：</p><ul><li>leave 类似于 break，跳出，结束当前所在的循环</li></ul><ol start='2' ><li>iterate类似于 continue，继续，结束本次循环，继续下一次</li></ol></li></ol><p><strong>WHILE</strong></p><p><code>//格式：</code></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n902" mdtype="fences">[标签:]WHILE 循环条件 DO
    循环体;
END WHILE[标签];
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n903" mdtype="fences">CREATE TABLE users (
    uid INT,
    username VARCHAR ( 50 ),
    PASSWORD VARCHAR ( 50 )
);
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n904" mdtype="fences">-- 创建存储过程：
DELIMITER $$
CREATE PROCEDURE proc1_while(IN insertcount INT)
BEGIN
    DECLARE i INT DEFAULT 1;
    label:WHILE i&lt;=insertcount DO
        INSERT INTO users(uid,username,PASSWORD) VALUES(i,CONCAT('user-',i),'123456');
        SET i=i+1;
    END WHILE label;
END $$
DELIMITER ;
-- 创建存储过程：
CALL proc1_while(10);
</pre><p><img src='https://img-blog.csdnimg.cn/1c66b463e15e445c92d87124367bca0d.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' />
<strong>WHILE+LEAVE</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n906" mdtype="fences" style="break-inside: unset;">-- 创建存储过程：
DELIMITER $$
CREATE PROCEDURE proc2_while(IN insertcount INT)
BEGIN
    DECLARE i INT DEFAULT 1;
    label:WHILE i&lt;=insertcount DO
        INSERT INTO users(uid,username,password) VALUES(i,CONCAT('user-',i),'123456');
        IF i=5 THEN 
        	LEAVE label;
        END IF;
        SET i=i+1;
    END WHILE label;
END $$
DELIMITER ;
-- 创建存储过程：
CALL proc2_while(10);
</pre><p><img src='https://img-blog.csdnimg.cn/0507e0fce9034b81be2e8759bb70c961.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' />
<strong>WHILE+ITERATE</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n908" mdtype="fences" style="break-inside: unset;">-- 创建存储过程：
DELIMITER $$
CREATE PROCEDURE proc3_while(IN insertcount INT)
BEGIN
    DECLARE i INT DEFAULT 1;
    label:WHILE i&lt;=insertcount DO
        SET i=i+1;
        IF i=5 THEN ITERATE label;
        END IF;
        INSERT INTO users(uid,username,password) VALUES(i,CONCAT('user-',i),'123456');
    END WHILE label;
END $$
DELIMITER ;
-- 创建存储过程：
CALL proc3_while(10);
</pre><p><img src='https://img-blog.csdnimg.cn/4a625d1b09064e21a3b80c5f8de9c7a2.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' />
<strong>REPEAT</strong></p><p><code>//格式：</code></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n911" mdtype="fences">[标签:]REPEAT 
 循环体;
UNTIL 条件表达式
END REPEAT [标签];
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n912" mdtype="fences" style="break-inside: unset;">-- 创建存储过程
DELIMITER $$
CREATE PROCEDURE proc1_repeat(IN insertCount INT)
BEGIN
     DECLARE i INT DEFAULT 1;
     label:REPEAT
         INSERT INTO users(uid, username, PASSWORD) VALUES(i,CONCAT('user-',i),'123456');
         SET i = i + 1;
         UNTIL  i  &gt; insertCount
     END REPEAT label;
     SELECT '循环结束';
END $$
DELIMITER ;
-- 创建存储过程：
CALL proc1_repeat(100);
</pre><p><strong>LOOP</strong></p><p><code>//格式：</code></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n915" mdtype="fences">[标签:] LOOP
  循环体;
  IF 条件表达式 THEN 
     LEAVE [标签]; 
  END IF;
END LOOP;
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n916" mdtype="fences" style="break-inside: unset;">-- 创建存储过程：
DELIMITER $$
CREATE PROCEDURE proc1_loop(IN insertCount INT) 
BEGIN
     DECLARE i INT DEFAULT 1;
     label:LOOP
         INSERT INTO users(uid, username, PASSWORD) VALUES(i,CONCAT('user-',i),'123456');
         SET i = i + 1;
         IF i &gt; 5 
          THEN 
           LEAVE label;
         END IF;
     END LOOP label;
     SELECT '循环结束';
END $$
DELIMITER ;
-- 创建存储过程：
CALL proc1_loop(10);
</pre><p><img src='https://img-blog.csdnimg.cn/2562ea8a76cd408ab9d692ef6ebfca96.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><h2><a name='header-n918' class='md-header-anchor '></a>3. 游标</h2><ul><li>游标(cursor)是用来存储查询结果集的数据类型 , 在存储过程和函数中可以使用光标对结果集进行循环的处理。</li><li>光标的使用包括光标的声明、OPEN、FETCH 和 CLOSE。</li></ul><p><code>//格式：</code></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n925" mdtype="fences">-- 声明
DECLARE cursor_name CURSOR FOR select_statement
-- 打开
OPEN cursor_name
-- 取值
FETCH cursor_name INTO var_name [, var_name] ...
-- 关闭
CLOSE cursor_name
</pre><p><img src='https://img-blog.csdnimg.cn/122598be61244f708c582ee70387c183.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n927" mdtype="fences" style="break-inside: unset;">-- 创建存储过程：
DELIMITER $$
CREATE PROCEDURE proc_cursor(IN in_dname VARCHAR(50))
BEGIN
-- 定义局部变量
 DECLARE var_empid INT;
 DECLARE var_ename VARCHAR(50);
 DECLARE var_sal  DECIMAL(7,2);
 
-- 声明游标
 DECLARE my_cursor CURSOR FOR
  SELECT emp_id , emp_name, salary 
    FROM  emp
    WHERE emp.department = in_dname;
    
-- 打开游标
 OPEN my_cursor;

-- 通过游标获取每一行数据
 label:LOOP
       FETCH my_cursor INTO var_empid, var_ename, var_sal;  
       SELECT var_empid, var_ename, var_sal;
 END LOOP label;
   
 -- 关闭游标
  CLOSE my_cursor;
END $$
DELIMITER ;
-- 调用存储过程
CALL proc_cursor('销售部');
</pre><p><strong>HANDLER句柄</strong></p><ul><li>MySql存储过程也提供了对异常处理的功能：通过定义HANDLER来完成异常声明的实现。</li></ul><p><code>//格式：</code></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n933" mdtype="fences" style="break-inside: unset;">DECLARE handler_action HANDLER
    FOR condition_value [, condition_value] ...
    statement
 
handler_action: {
    CONTINUE
  | EXIT
  | UNDO
}
 
 condition_value: {
    mysql_error_code
  | condition_name
  | SQLWARNING
  | NOT FOUND
  | SQLEXCEPTION
</pre><p><code>// 存储过程中的handler：</code></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n935" mdtype="fences" style="break-inside: unset;">-- 创建存储过程：
DELIMITER $$
CREATE PROCEDURE proc2_cursor(IN in_dname VARCHAR(50))
BEGIN
    -- 定义局部变量
    DECLARE var_empno INT;
    DECLARE var_ename VARCHAR(50);
    DECLARE var_sal DECIMAL(7,2);
    DECLARE flag INT DEFAULT 1; -- 标志位
    
    -- 声明游标
    DECLARE my_cursor CURSOR FOR
        SELECT emp_id,emp_name,salary
        FROM emp
        WHERE emp.department = in_dname;
        
    /* 定义句柄：定义异常处理的方式：
		
		1.异常处理完之后程序该怎么执行?
			continue：继续执行剩余代码
			exit：直接终止程序
			undo：不支持
		2.触发条件?
			条件码：
				1329
			条件名：
				SQLWARNING
				NOT FOUND
				SQLEXCEPTION
		3.异常触发之后执行什么代码?
			设置flag值--&gt;0
    */
    
    -- 定义句柄，当数据未发现时将标记位设置为0
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET flag = 0;   

    -- 打开游标
    OPEN my_cursor;
    -- 通过游标获取值
    label:LOOP
        FETCH my_cursor INTO var_empno, var_ename,var_sal;
        -- 判断标志位
        IF flag = 1 THEN
            SELECT var_empno, var_ename,var_sal;
        ELSE
            LEAVE label;
        END IF;
    END LOOP label;
    
    -- 关闭游标
    CLOSE my_cursor;
END $$
DELIMITER ;
-- 调用存储过程：
CALL proc2_cursor('销售部');
</pre><h2><a name='header-n936' class='md-header-anchor '></a>4. 存储函数</h2><ul><li>MySQL存储函数（自定义函数），函数一般用于计算和返回一个值，可以将经常需要使用的计算或功能写成一个函数。</li><li>存储函数和存储过程一样，都是在数据库中定义一些 SQL 语句的集合。</li><li>存储函数与存储过程的区别</li></ul><ol start='' ><li>存储函数有且只有一个返回值，而存储过程可以有多个返回值，也可以没有返回值。 </li><li>存储函数只能有输入参数，而且不能带in, 而存储过程可以有多个in,out,inout参数。</li><li>存储过程中的语句功能更强大，存储过程可以实现很复杂的业务逻辑，而函数有很多限制，如不能在函数中使用insert,update,delete,create等语句；</li><li>存储函数只完成查询的工作，可接受输入参数并返回一个结果，也就是函数实现的功能针对性比较强。</li><li>存储过程可以调用存储函数。但函数不能调用存储过程。</li><li>存储过程一般是作为一个独立的部分来执行(call调用)。而函数可以作为查询语句的一个部分来调用.</li></ol><p><code>//格式：</code></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n958" mdtype="fences">CREATE FUNCTION func_name ([param_name TYPE[,...]])
RETURNS TYPE
[characteristic ...] 
BEGIN
    routine_body
END;
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n959" mdtype="fences"> 参数说明：
（1）func_name ：存储函数的名称。
（2）param_name type：可选项，指定存储函数的参数。type参数用于指定存储函数的参数类型，该类型可以是MySQL数据库中所有支持的类型。
（3）RETURNS type：指定返回值的类型。
（4）characteristic：可选项，指定存储函数的特性。
（5）routine_body：SQL代码内容。
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n960" mdtype="fences">-- 允许创建函数信任
SET GLOBAL log_bin_trust_function_creators=TRUE; 
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n961" mdtype="fences">-- 创建存储函数-没有输输入参数
DELIMITER $$
CREATE FUNCTION func1_emp() RETURNS INT
BEGIN
  DECLARE cnt INT DEFAULT 0;
    SELECT COUNT(*) INTO  cnt FROM emp;
  RETURN cnt;
END $$
DELIMITER ;
-- 调用存储函数
SELECT func1_emp();
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n962" mdtype="fences">-- 创建存储过程-有输入参数 
DELIMITER $$
CREATE FUNCTION func2_emp(in_empno INT) RETURNS VARCHAR(50)
BEGIN
    DECLARE out_name VARCHAR(50);
    SELECT emp_name INTO out_name FROM emp WHERE  emp_id = in_empno;
    RETURN out_name;
END $$
DELIMITER ;
-- 调用存储函数
SELECT func2_emp(7);
</pre><h2><a name='header-n963' class='md-header-anchor '></a>5. 触发器</h2><ul><li>触发器，就是一种特殊的存储过程。</li></ul><ol start='' ><li>触发器和存储过程一样是一个能够完成特定功能、存储在数据库服务器上的SQL片段，</li><li>触发器无需调用，当对数据库表中的数据执行DML操作时自动触发这个SQL片段的执行，无需手动条用。</li><li>在MySQL中，只有执行insert,delete,update操作时才能触发触发器的执行</li><li>触发器的这种特性可以协助应用在数据库端确保数据的完整性 , 日志记录 , 数据校验等操作 。</li><li>使用别名 OLD 和 NEW 来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。</li></ol><ul><li>触发器的特性：</li></ul><blockquote><p>1、什么条件会触发：I、D、U
2、什么时候触发：在增删改前或者后
3、触发频率：针对每一行执行
4、触发器定义在表上，附着在表上</p></blockquote><p><code>//格式：</code></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n984" mdtype="fences">-- 1、创建只有一个执行语句的触发器
CREATE TRIGGER 触发器名 BEFORE|AFTER 触发事件
ON 表名 FOR EACH ROW 
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n985" mdtype="fences">-- 2、创建有多个执行语句的触发器
CREATE TRIGGER 触发器名 BEFORE|AFTER  触发事件 
ON 表名 FOR EACH ROW
BEGIN
     执行语句列表
END;
</pre><p><code>//数据准备：</code></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n987" mdtype="fences">-- 用户表
CREATE TABLE users(
    uid INT PRIMARY KEY ,
    username VARCHAR(50) NOT NULL,
    PASSWORD VARCHAR(50) NOT NULL
);
-- 用户信息操作日志表
CREATE TABLE user_logs(
    id INT PRIMARY KEY AUTO_INCREMENT,
    TIME TIMESTAMP,
    log_text VARCHAR(255)
);
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n988" mdtype="fences">-- 查看触发器
SHOW TRIGGERS;
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n989" mdtype="fences">-- 删除触发器
DROP TRIGGER [IF EXISTS] trigger_name 
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n990" mdtype="fences">-- 创建触发器trigger1
CREATE TRIGGER trigger1
AFTER INSERT ON users -- 触发时机：添加users表数据时触发
FOR EACH ROW
INSERT INTO user_logs VALUES(NULL,NOW(), '有新用户注册');
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n991" mdtype="fences">INSERT INTO users VALUES(1,'张三','123456');
</pre><p><img src='https://img-blog.csdnimg.cn/f77b2c851a154366a059bef0b30a310d.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n993" mdtype="fences">-- 创建触发器trigger2
DELIMITER $$
CREATE TRIGGER trigger2
AFTER UPDATE ON users  -- 触发时机：修改users表数据时触发
FOR EACH ROW -- 每一行
BEGIN
INSERT INTO user_logs VALUES(NULL,NOW(), '用户修改发生了修改');
END $$
DELIMITER ;
</pre><p><strong>NEW与OLD</strong></p><ul><li>MySQL 中定义了 NEW 和 OLD，用来表示触发器的所在表中，触发了触发器的那一行数据，来引用触发器中发生变化的记录内容。</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n998" mdtype="fences">触发器类型 				触发器类型NEW 和 OLD的使用
INSERT 型触发器			NEW 表示将要或者已经新增的数据
UPDATE 型触发器			OLD 表示修改之前的数据 , NEW 表示将要或已经修改后的数据
DELETE 型触发器			OLD 表示将要或者已经删除的数据
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n999" mdtype="fences">NEW.columnName (columnName为相应数据表某一列名)
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1000" mdtype="fences">-- INSERT触发器NEW
CREATE TRIGGER trigger3 AFTER INSERT
ON users FOR EACH ROW
INSERT INTO user_logs VALUES(NULL,NOW(),CONCAT('有新用户注册，信息为:',NEW.uid,NEW.username,NEW.password));
-- 测试
INSERT INTO users VALUES(2,'赵六','123456');
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1001" mdtype="fences">-- UPDATE触发器NEW&amp;OLD
CREATE TRIGGER trigger4 AFTER UPDATE
ON users FOR EACH ROW
INSERT INTO user_logs VALUES(NULL,NOW(),CONCAT_WS(',','有用户信息修改，修改前 信息为:',OLD.uid,OLD.username,OLD.password));
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1002" mdtype="fences">-- DELETE触发器OLD
CREATE TRIGGER trigger5 AFTER DELETE
ON users FOR EACH ROW
INSERT INTO user_logs VALUES(NULL,NOW(),CONCAT_WS(',','有用户信息被删除，修改前的信息为:',OLD.uid,OLD.username,OLD.password));
</pre><p><strong>注意：</strong></p><ol start='' ><li>MYSQL中触发器中不能对本表进行 insert ,update ,delete 操作，以免递归循环触发</li><li>尽量少使用触发器，假设触发器触发每次执行1s，insert table 500条数据，那么就需要触发500次触发器，光是触发器执行的时间就花费了500s，insert 500条数据一共是1s，那么这个insert的效率就非常低了。</li><li>触发器是针对每一行的；对增删改非常频繁的表上切记不要使用触发器，因为它会非常消耗资源。</li></ol><h2><a name='header-n1011' class='md-header-anchor '></a>6. 索引</h2><blockquote><p>索引是通过某种算法，构建出一个数据模型，用于快速找出在某个列中有一特定值的行，不使用索引，MySQL必须从第一条记录开始读完整个表，直到找出相关的行，表越大，查询数据所花费的时间就越多，如果表中查询的列有一个索引，MySQL能够快速到达一个位置去搜索数据文件，而不必查看所有数据，那么将会节省很大一部分时间。</p></blockquote><ul><li>索引的分类</li></ul><ol start='' ><li>索引是存储引擎用来快速查找记录的一种数据结构，按照实现的方式类分，主要有Hash索引和B+Tree索引。</li><li>按照功能划分，索引划为以下分类:组合索引，空间索引，全文索引，单列索引：普通索引，唯一索引，主键索引。</li></ol><ul><li>单列索引：一个索引只包含单个列，但一个表中可以有多个单列索引;</li></ul><p><code>//创建索引--单列索引--普通索引：</code></p><p><strong>普通索引：</strong> MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值，纯粹为了查询数据更快一点。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1027" mdtype="fences">-- 方式1-创建表的时候直接指定
CREATE TABLE student(
    sid INT PRIMARY KEY,
    card_id VARCHAR(20),
    NAME VARCHAR(20),
    gender VARCHAR(20),
    age INT,
    birth DATE, 
    phone_num VARCHAR(20),
    score DOUBLE,
    INDEX index_name(NAME) -- 给NAME列创建索引
);
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1028" mdtype="fences">-- 方式2-直接创建
create index indexname on tablename(columnname); 
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1029" mdtype="fences">-- 方式3-修改表结构(添加索引)
alter table tablename add index indexname(columnname)
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1030" mdtype="fences">-- 1、查看数据库所有索引 
select * from mysql.innodb_index_stats a where a.database_name = '数据库名'; 
</pre><p>&nbsp;</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1032" mdtype="fences">-- 2、查看表中所有索引 
select * from mysql.innodb_index_stats a where a.database_name = '数据库名' and a.table_name like '%表名%'; 
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1033" mdtype="fences">-- 3、查看表中所有索引 
show index from table_name; 
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1034" mdtype="fences">-- 删除索引
DROP INDEX 索引名 ON 表名 
或 
ALTER TABLE 表名 DROP INDEX 索引名 
</pre><p><code>//创建索引--单列索引--唯一索引：</code></p><ul><li>唯一索引与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。它有以下几种创建方式：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1039" mdtype="fences">-- 方式1-创建表的时候直接指定
CREATE  TABLE student2(
    sid INT PRIMARY KEY,
    card_id VARCHAR(20),
    NAME VARCHAR(20),
    gender VARCHAR(20),
    age INT,
    birth DATE, 
    phone_num VARCHAR(20),
    score DOUBLE,
    UNIQUE index_card_id(card_id) -- 给card_id列创建索引
);
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1040" mdtype="fences">-- 方式2-直接创建
create unique index 索引名 on 表名(列名) 
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1041" mdtype="fences">-- 方式3-修改表结构(添加索引)
alter table 表名 add unique [索引名] (列名)
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1042" mdtype="fences">-- 删除索引
DROP INDEX 索引名 ON 表名;
或 
ALTER TABLE 表名 DROP INDEX 索引名;
</pre><p>&nbsp;</p><p><code>//创建索引--单列索引--主键索引：</code></p><ul><li>每张表一般都会有自己的主键，当我们在创建表时，MySQL会自动在主键列上建立一个索引，这就是主键索引。</li><li>主键是具有唯一性并且不允许为NULL，所以他是一种特殊的唯一索引。</li></ul><p><code>//创建索引--组合索引：</code></p><ul><li>组合索引也叫复合索引，指的是我们在建立索引的时候使用多个字段，例如同时使用身份证和手机号建立索引，同样的可以建立为普通索引或者是唯一索引。</li><li>复合索引的使用复合最左原则。</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1056" mdtype="fences">-- 创建组合索引
CREATE INDEX indexname ON table_name(column1(LENGTH),column2(LENGTH)); 
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1057" mdtype="fences">-- 删除索引
DROP INDEX index_name ON table_name; 
</pre><p><code>//全文索引：</code></p><ul><li>全文索引主要用来查找文本中的关键字，而不是直接与索引中的值相比较，更像是一个搜索引擎，基于相似度的查询，而不是简单的where语句的参数匹配。</li><li>全文索引的版本、存储引擎、数据类型的支持情况：</li></ul><ol start='' ><li>MySQL 5.6 以前的版本，只有 MyISAM 存储引擎支持全文索引；</li><li>MySQL 5.6 及以后的版本，MyISAM 和 InnoDB 存储引擎均支持全文索引;</li><li>只有字段的数据类型为 char、varchar、text 及其系列才可以建全文索引；</li><li>在数据量较大时候，现将数据放入一个没有全局索引的表中，然后再用create index创建fulltext索引，要比先为一张表建立fulltext然后再将数据写入的速度快很多；</li><li>测试或使用全文索引时，要先看一下自己的 MySQL 版本、存储引擎和数据类型是否支持全文索引。</li></ol><blockquote><p>MySQL 中的全文索引，有两个变量，最小搜索长度和最大搜索长度，
 对于长度小于最小搜索长度和大于最大搜索长度的词语，都不会被索引。
 通俗点就是说，想对一个词语使用全文索引搜索，那么这个词语的长度必须在以上两个变量的区间内。
 这两个的默认值可以使用以下命令查看: 
 SHOW VARIABLES LIKE &#39;%ft%&#39;;</p></blockquote><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="j" contenteditable="false" cid="n1077" mdtype="fences">参数解释：
#		参数名称						 默认值		 最小值		 最大值			作用
1	ft_min_word_len			    	4		    1 		  3600 		MyISAM 引擎表全文索引包含的最小词长度
2	ft_query_expansion_limit	   20		    0		  1000		MyISAM引擎表使用 with query expansion 进行全文搜索的最大匹配数
3	innodb_ft_min_token_size	    3		    0		    16		InnoDB 引擎表全文索引包含的最小词长度
4	innodb_ft_max_token_size	   84 		   10		    84		InnoDB 引擎表全文索引包含的最大词长度
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1078" mdtype="fences" style="break-inside: unset;">数据准备：
创建表的时候添加全文索引
CREATE TABLE t_article (
     id INT PRIMARY KEY AUTO_INCREMENT ,
     title VARCHAR(255) ,
     content VARCHAR(1000) ,
     writing_date DATE -- , 
     -- fulltext (content) -- 创建全文检索
);

INSERT INTO t_article VALUES(NULL,"Yesterday Once More","When I was young I listen to the radio",'2021-10-01');
INSERT INTO t_article VALUES(NULL,"Right Here Waiting","Oceans apart, day after day,and I slowly go insane",'2021-10-02'); 
INSERT INTO t_article VALUES(NULL,"My Heart Will Go On","every night in my dreams,i see you, i feel you",'2021-10-03');
INSERT INTO t_article VALUES(NULL,"Everything I Do","eLook into my eyes,You will see what you mean to me",'2021-10-04');
INSERT INTO t_article VALUES(NULL,"Called To Say I Love You","say love you no new year's day, to celebrate",'2021-10-05');
INSERT INTO t_article VALUES(NULL,"Nothing's Gonna Change My Love For You","if i had to live my life without you near me",'2021-10-06');
INSERT INTO t_article VALUES(NULL,"Everybody","We're gonna bring the flavor show U how.",'2021-10-07');
</pre><p><code>//创建全文索引：</code></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1080" mdtype="fences">-- 修改表结构添加全文索引
ALTER TABLE t_article ADD FULLTEXT index_content(content)
 
-- 直接添加全文索引
CREATE FULLTEXT INDEX index_content ON t_article(content);
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1081" mdtype="fences">-- 使用索引
-- 使用全文索引和常用的模糊匹配使用 like + % 不同，
-- 全文索引有自己的语法格式，使用 match 和 against 关键字
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1082" mdtype="fences">MATCH (col1,col2,...)  AGAINST(expr [search_modifier])
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1083" mdtype="fences">SELECT * FROM t_article WHERE MATCH(content) AGAINST('yo'); -- 没有结果 单词数需要大于等于3 
SELECT * FROM t_article WHERE MATCH(content) AGAINST('you'); -- 有结果
</pre><p><code>//空间索引：</code></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1085" mdtype="fences">MySQL在5.7之后的版本支持了空间索引，而且支持OpenGIS几何数据模型。
空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON。
MYSQL使用SPATIAL关键字进行扩展，使得能够用于创建正规索引类型的语法创建空间索引。
创建空间索引的列，必须将其声明为NOT NULL。
空间索引一般是用的比较少，了解即可。
</pre><blockquote><p>Geometry<span>		</span>-- 空间数据<span>	</span>--<span>	</span>任何一种空间类型
Point<span>			</span>    --  点<span>		</span>--<span>	</span>坐标值
LineString<span>		</span>--     线<span>	</span>--<span>		</span>有一系列点连接而成
Polygon<span>	</span>--<span>	</span>     多边形<span>	</span>--<span>	</span>由多条线组成</p></blockquote><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1088" mdtype="fences">CREATE TABLE shop_info (
  id  INT  PRIMARY KEY AUTO_INCREMENT COMMENT 'id',
  shop_name VARCHAR(64) NOT NULL COMMENT '门店名称',
  geom_point GEOMETRY NOT NULL COMMENT '经纬度',
  SPATIAL KEY geom_index(geom_point)
);
</pre><p><strong>索引总结：</strong></p><blockquote><p>索引的优点：大大加快数据的查询速度，使用分组和排序进行数据查询时，可以显著减少查询时分组和排序的时间，创建唯一索引，能够保证数据库表中每一行数据的唯一性，在实现数据的参考完整性方面，可以加速表和表之间的连接。</p></blockquote><blockquote><p>索引的缺点：创建索引和维护索引需要消耗时间，并且随着数据量的增加，时间也会增加，索引需要占据磁盘空间，对数据表中的数据进行增加，修改，删除时，索引也要动态的维护，降低了维护的速度。</p></blockquote><blockquote><p>创建索引的原则：更新频繁的列不应设置索引，数据量小的表不要使用索引，重复数据多的字段不应设为索引，首先应该考虑对where 和 ORDER BY 涉及的列上建立索引。</p></blockquote><h2><a name='header-n1096' class='md-header-anchor '></a>7. 存储引擎</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1097" mdtype="fences" style="break-inside: unset;">数据库存储引擎是数据库底层软件组织，数据库管理系统（DBMS）使用数据引擎进行创建、查询、更新和删除数据。
不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能。
现在许多不同的数据库管理系统都支持多种不同的数据引擎。
MySQL的核心就是存储引擎。
用户可以根据不同的需求为数据表选择不同的存储引擎

可以使用 SHOW ENGINES 命令 可以查看Mysql的所有执行引擎我们 可以到 默认的执行引擎是innoDB 支持事务，行级锁定和外键。

分类：

 MyISAM：Mysql 5.5之前的默认数据库引擎，最为常用。拥有较高的插入，查询速度，但不支持事务

 InnoDB：事务型速记的首选引擎，支持ACID事务，支持行级锁定，MySQL5.5成为默认数据库引擎

 Memory： 所有数据置于内存的存储引擎，拥有极高的插入，更新和查询效率，但是会占用和数据量成正比的内存空间。并且其内容会在MYSQL重新启动是会丢失。
 
 Archive ：非常适合存储大量的独立的，作为历史记录的数据。因为它们不经常被读取，Archive 拥有高效的插入速度，但其对查询的支持相对较差
 
 Federated ：将不同的 MySQL 服务器联合起来，逻辑上组成一个完整的数据库。非常适合分布式应用

 CSV ：逻辑上由逗号分割数据的存储引擎。它会在数据库子目录里为每个数据表创建一个 .csv 文件，这是一种普通文本文件，每个数据行占用一个文本行。CSV 存储引擎不支持索引。
 
 BlackHole： 黑洞引擎，写入的任何数据都会消失，一般用于记录 binlog 做复制的中继
 
 ERFORMANCE_SCHEMA存储引擎该引擎主要用于收集数据库服务器性能参数。
 
 Mrg_Myisam Merge存储引擎，是一组MyIsam的组合，也就是说，他将MyIsam引擎的多个表聚合起来，但是他的内部没有数据，真正的数据依然是MyIsam引擎的表中，但是可以直接进行查询、删除更新等操作。
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1098" mdtype="fences">-- 查询当前数据库支持的存储引擎：
show engines;
</pre><p><img src='https://img-blog.csdnimg.cn/9f61d3539a7b48f3b5d9c64ba6872ce5.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1100" mdtype="fences">-- 查看当前的默认存储引擎
show variables like '%storage_engine%';
</pre><p><img src='https://img-blog.csdnimg.cn/e00d0b6ecce44f53b5293bdb2c9ff84e.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1102" mdtype="fences">-- 查看某个表用了什么引擎(在显示结果里参数engine后面的就表示该表当前用的存储引擎): 
show create table student; 
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1103" mdtype="fences">-- 创建新表时指定存储引擎：
create table(...) engine=MyISAM;
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1104" mdtype="fences">-- 修改数据库引擎
alter table tablename engine = INNODB;
alter table tablename engine = MyISAM;
</pre><ul><li><p>修改MySQL默认存储引擎方法</p><ol start='' ><li>关闭mysql服务 ；</li><li>找到mysql安装目录下的my.ini文件；</li><li>找到default-storage-engine=INNODB 改为目标引擎；</li><li>启动mysql服务。</li></ol></li></ul><hr /><hr /><hr /><p>﻿@<a href='%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86'>TOC</a></p><p>&nbsp;</p><h1><a name='header-n1122' class='md-header-anchor '></a>事务，锁机制，日志，MySQL优化</h1><h2><a name='header-n1123' class='md-header-anchor '></a>1. 事务</h2><ul><li>在MySQL中的事务（Transaction）是由存储引擎实现的，在MySQL中，只有InnoDB存储引擎才支持事务。</li><li>事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。</li><li>事务用来管理 DDL、DML、DCL 操作，比如 insert,update,delete 语句，默认是自动提交的。 </li><li>理解事务：</li></ul><blockquote><p>在银行转账时，必须保证转账绝对安全，这时需要事务参与:
UPDATE account SET money = money - 200 WHERE id = 1; 
UPDATE account SET money = money + 200 WHERE id = 2;
假如在第一次update之后，出现了意外、异常，没有执行第二次update，这时转账是否会出现异常？</p></blockquote><ul><li><strong>事务操作：</strong></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1138" mdtype="fences">1、开启事务：Start Transaction
	 任何一条DML语句(insert、update、delete)执行，标志事务的开启
	 命令：BEGIN 或 START TRANSACTION
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1139" mdtype="fences">2、提交事务：Commit Transaction
	 成功的结束，将所有的DML语句操作历史记录和底层硬盘数据来一次同步
	 命令：COMMIT
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1140" mdtype="fences">3、回滚事务：Rollback Transaction
	 失败的结束，将所有的DML语句操作历史记录全部清空
	 命令：ROLLBACK 
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1141" mdtype="fences">MySQL中直接用 SET 来改变 MySQL 的自动提交模式
SET autocommit=0; -- 禁止自动提交 
SET autocommit=1; -- 开启自动提交 
</pre><p><code>//模拟银行转账操作：</code></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1143" mdtype="fences" style="break-inside: unset;">-- 创建账户表
CREATE TABLE account(
    id INT PRIMARY KEY, -- 账户id
    NAME VARCHAR(20), -- 账户名
    money DOUBLE -- 金额
);
 
--  插入数据
INSERT INTO account VALUES(1,'张三',800);
INSERT INTO account VALUES(2,'李四',1000);
	
-- 设置MySQL的事务为手动提交(关闭自动提交)
SELECT @@autocommit;
SET autocommit = 0;
 
-- 模拟账户转账
-- 开启事务 
BEGIN;
UPDATE account SET money = money - 200 WHERE NAME = '张三';
UPDATE account SET money = money + 200 WHERE NAME = '李四';
-- 提交事务
COMMIT;
-- 如果转账中的任何一条出现问题，则回滚事务
ROLLBACK;
</pre><p><strong>事务的特性</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1145" mdtype="fences">事务的特性：
	·原子性：事务是一个不可分割的整体，事务开始后的操作要么全部完成，要么全部不做
	·一致性：事务从一个正确的状态迁移到另一个正确的状态
	·隔离性：每个事务的对象对其他事务的操作对象互相分离，事务提交前对其他事务不可见
	·持久性：事务一旦提交，则其结果是永久性的
</pre><p><strong>事务的隔离级别</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1147" mdtype="fences">事务的隔离级别：
	·如果一个事务正在操作的数据被另一个事务修改或删除了，最后的执行结果可能无法达到预期。
	·如果没有隔离性还会导致其他问题。
	·READ UNCOMMITTED		读未提交
	·READ COMMITTED	 		读提交
	·REPEATEABLE READ		可重复读
	·SERIALIZABLE			序列化
</pre><blockquote><p>读未提交(Read uncommitted)：一个事务可以读取另一个未提交事务的数据，最低级别，任何情况都无法保证,会造成脏读。
~
读已提交(Read committed)：一个事务要等另一个事务提交后才能读取数据，可避免脏读的发生，会造成不可重复读。
~
可重复读(Repeatable read)：就是在开始读取数据（事务开启）时，不再允许修改操作，可避免脏读、不可重复读的发生，但是会造成幻读。
~
串行(Serializable)：是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读，但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。</p><p>~
Mysql的默认隔离级别是Repeatable read。</p></blockquote><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1151" mdtype="fences">查看隔离级别 
SHOW VARIABLES LIKE '%isolation%'; 
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1152" mdtype="fences">设置隔离级别：set session transaction isolation level 级别字符串
级别字符串：read uncommitted、read committed、repeatable read、serializable
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1153" mdtype="fences">-- 设置read uncommitted
SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
 
-- 设置read committed
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
 
-- 设置repeatable read
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;
 
-- 设置serializable
SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;
</pre><h2><a name='header-n1154' class='md-header-anchor '></a>2. 锁机制</h2><ul><li><p>锁是计算机协调多个进程或线程并发访问某一资源的机制（避免争抢）。</p></li><li><p>分类：</p></li><li><blockquote><p>从对数据操作的粒度分 ： 
1） 表锁：操作时，会锁定整个表。
2） 行锁：操作时，会锁定当前操作行。</p></blockquote></li><li><blockquote><p>从对数据操作的类型分：
1） 读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会互相影响。
2） 写锁（排它锁）：当前操作没有完成之前，它会阻断其他写锁和读锁。</p></blockquote></li><li><p>MySQL中各存储引擎对锁的支持情况：</p></li><li><p><code>存储引擎		 表级锁		    行级锁</code>
<code>MyISAM					  支持			不支持</code>
<code>InnoDB				  支持				  支持</code>
<code>MEMORY			  支持				不支持</code>
<code>BDB				  	支持					不支持</code></p></li></ul><p><strong>表级锁</strong><span>	</span></p><p>特点：</p><ol start='' ><li>偏向MyISAM存储引擎，开销小，加锁快，不会出现死锁；</li><li>锁定粒度大，发生锁冲突的概率最高，并发度最低。</li></ol><p><strong>行级锁</strong><span>	</span></p><p>特点：</p><ol start='' ><li>偏向InnoDB存储引擎，开销大，加锁慢，会出现死锁；</li><li>锁定粒度最小，发生锁冲突的概率最低，并发度最高。</li></ol><p>** MyISAM 表锁**</p><ul><li>MyISAM 存储引擎只支持表锁。</li><li>MyISAM 在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT 等）前，会自动给涉及的表加写锁，不需要用户干预，用户一般不需要直接用 LOCK TABLE 命令给 MyISAM 表显式加锁。</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1190" mdtype="fences">加读锁 ： 
lock table table_name read; 
加写锁 ： 
lock table table_name write;
</pre><p> <strong>表锁特点：</strong></p><ol start='' ><li>对MyISAM 表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；</li><li>对MyISAM 表的写操作，则会阻塞其他用户对同一表的读和写操作。</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1197" mdtype="fences">CREATE TABLE tb_book (
  id INT(11) AUTO_INCREMENT,
  NAME VARCHAR(50) DEFAULT NULL,
  publish_time DATE DEFAULT NULL,
  STATUS CHAR(1) DEFAULT NULL,
  PRIMARY KEY (id)
) ENGINE=MYISAM DEFAULT CHARSET=utf8 ;
LOCK TABLE tb_book READ; -- 加读锁
INSERT INTO tb_book (id, NAME, publish_time, STATUS) VALUES(NULL,'java编程思想','2088-08-01','1');
INSERT INTO tb_book (id, NAME, publish_time, STATUS) VALUES(NULL,'solr编程思想','2088-08-08','0');
UNLOCK TABLES;
</pre><p><strong>InnoDB行锁</strong></p><ul><li><p>行锁特点 ：偏向InnoDB 存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</p></li><li><p>InnoDB 与 MyISAM 的最大不同有两点：一是支持事务；二是 采用了行级锁。</p></li><li><p>InnoDB  实现了以下两种类型的行锁：</p><ol start='' ><li>共享锁（S）：又称为读锁，简称S锁，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。</li><li>排他锁（X）：又称为写锁，简称X锁，排他锁就是不能与其他锁并存，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据就行读取和修改。</li></ol></li><li><p>对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；</p></li><li><p>对于普通SELECT语句，InnoDB不会加任何锁；</p></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1215" mdtype="fences">共享锁（S）：
SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE;
排他锁（X) ：
SELECT * FROM table_name WHERE ... FOR UPDATE;
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1216" mdtype="fences" style="break-inside: unset;">-- 行锁 
DROP TABLE IF EXISTS test_innodb_lock;
CREATE TABLE test_innodb_lock(
    id INT(11),
    NAME VARCHAR(16),
    sex VARCHAR(1)
)ENGINE = INNODB;
 
INSERT INTO test_innodb_lock VALUES(1,'100','1');
INSERT INTO test_innodb_lock VALUES(3,'300','1');
INSERT INTO test_innodb_lock VALUES(4,'400','0');
INSERT INTO test_innodb_lock VALUES(5,'500','1');
INSERT INTO test_innodb_lock VALUES(6,'600','0');
INSERT INTO test_innodb_lock VALUES(7,'700','0');
INSERT INTO test_innodb_lock VALUES(8,'800','1');
INSERT INTO test_innodb_lock VALUES(9,'900','1');
INSERT INTO test_innodb_lock VALUES(1,'200','0');

SELECT * FROM test_innodb_lock;
UPDATE test_innodb_lock SET NAME = '300' WHERE id = 3;
CREATE INDEX idx_test_innodb_lock_id ON test_innodb_lock(id);
CREATE INDEX idx_test_innodb_lock_name ON test_innodb_lock(NAME);
</pre><h2><a name='header-n1217' class='md-header-anchor '></a>3. 日志</h2><ul><li>日志分类：</li></ul><ol start='' ><li>错误日志</li><li>二进制日志</li><li>查询日志</li><li>慢查询日志</li></ol><p><strong>错误日志：</strong></p><ol start='' ><li>错误日志是 MySQL 中最重要的日志之一，它记录了当 mysqld 启动和停止时，以及服务器在运行过程中发生任何严重错误时的相关信息。</li><li>当数据库出现任何故障导致无法正常使用时，可以首先查看此日志。</li><li>该日志是默认开启的 ， 默认存放目录为 mysql 的数据目录, 默认的日志文件名为  hostname.err（hostname是主机名）。</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1238" mdtype="fences">查看日志位置指令 ： 
SHOW VARIABLES LIKE 'log_error%';
</pre><p><strong>二进制日志-binlog：</strong></p><ol start='' ><li>二进制日志（BINLOG）记录了所有的 DDL（数据定义语言）语句和 DML（数据操纵语言）语句，但是不包括数据查询语句。</li><li>此日志对于灾难时的数据恢复起着极其重要的作用，MySQL的主从复制， 就是通过该binlog实现的。</li><li>二进制日志，MySQl8.0默认已经开启，低版本的MySQL的需要通过配置文件开启，并配置MySQL日志的格式。 Windows系统：my.ini    Linux系统:my.cnf </li><li>配置开启binlog日志， 日志的文件前缀为 mysqlbin -----&gt; 生成的文件名如 : mysqlbin.000001,mysqlbin.000002
log_bin=mysqlbin</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1249" mdtype="fences">配置二进制日志的格式
binlog_format=STATEMENT
</pre><p><strong>日志格式：</strong></p><blockquote><p>该日志格式在日志文件中记录的都是SQL语句（statement），每一条对数据进行修改的SQL都会记录在日志文件中，通过Mysql提供的mysqlbinlog工具，可以清晰的查看到每条语句的文本。
主从复制的时候，从库（slave）会将日志解析为原文本，并在从库重新执行一次。</p></blockquote><blockquote><p>ROW
 该日志格式在日志文件中记录的是每一行的数据变更，而不是记录SQL语句。比如，执行SQL语句 ： update tb_book set status=&#39;1&#39; , 如果是STATEMENT 日志格式，在日志中会记录一行SQL文件；
 如果是ROW，由于是对全表进行更新，也就是每一行记录都会发生变更，ROW 格式的日志中会记录每一行的数据变更。</p></blockquote><blockquote><p>MIXED 
混合了STATEMENT 和 ROW两种格式。</p></blockquote><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1257" mdtype="fences">查看MySQL是否开启了binlog日志
SHOW VARIABLES LIKE 'log_bin';
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1258" mdtype="fences">查看binlog日志的格式
SHOW VARIABLES LIKE 'binlog_format';
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1259" mdtype="fences">查看所有日志
SHOW BINLOG EVENTS;
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1260" mdtype="fences">查看最新的日志
SHOW MASTER STATUS;
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1261" mdtype="fences">查询指定的binlog日志
SHOW BINLOG EVENTS IN 'binlog.000010';
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1262" mdtype="fences">从指定的位置开始,查看指定的Binlog日志
SHOW BINLOG EVENTS IN 'binlog.000010' FROM 156;
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1263" mdtype="fences"> 从指定的位置开始,查看指定的Binlog日志,限制查询的条数
SHOW BINLOG EVENTS IN 'binlog.000010' FROM 16579 LIMIT 2;
</pre><p> </p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1265" mdtype="fences">从指定的位置开始，带有偏移，查看指定的Binlog日志,限制查询的条数
SHOW BINLOG EVENTS IN 'binlog.000010' FROM 16579 LIMIT 1, 2;
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1266" mdtype="fences">清空所有的 binlog 日志文件
RESET MASTER;
</pre><p><strong>查询日志：</strong></p><blockquote><p>查询日志中记录了客户端的所有操作语句，而二进制日志不包含查询数据的SQL语句。
默认情况下， 查询日志是未开启的。如果需要开启查询日志，可以设置以下配置 ：该选项用来开启查询日志 ， 可选值 ： 0 或者 1 ； 0 代表关闭， 1 代表开启， general_log=1</p></blockquote><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1270" mdtype="fences">设置日志的文件名 ， 如果没有指定， 默认的文件名为 host_name.log 
general_log_file=file_name
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1271" mdtype="fences">查看MySQL是否开启了查询日志
SHOW VARIABLES LIKE 'general_log';
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1272" mdtype="fences">开启查询日志
SET GLOBAL  general_log=1;
</pre><p><strong>慢查询日志：</strong></p><blockquote><p>慢查询日志记录了所有执行时间超过参数 long_query_time 设置值并且扫描记录数不小于 min_examined_row_limit 的所有的SQL语句的日志。
long_query_time 默认为 10 秒，最小为 0，精度可以到微秒。该参数用来控制慢查询日志是否开启，可取值：1和0，1代表开启，0代表关闭，slow_query_log=1</p></blockquote><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1276" mdtype="fences">该参数用来指定慢查询日志的文件名
slow_query_log_file=slow_query.log
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1277" mdtype="fences">该选项用来配置查询的时间限制， 超过这个时间将认为值慢查询， 将需要进行日志记录， 默认10s
long_query_time=10
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1278" mdtype="fences">查看慢日志查询是否开启
SHOW VARIABLES LIKE 'slow_query_log%';
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1279" mdtype="fences">开启慢查询日志
SET GLOBAL slow_query_log = 1;
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1280" mdtype="fences">查看慢查询的超时时间
SHOW VARIABLES LIKE 'long_query_time%';
</pre><h2><a name='header-n1281' class='md-header-anchor '></a>4. 优化</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1282" mdtype="fences">-- 休眠10s钟
SELECT SLEEP(10); 
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1283" mdtype="fences">从设计上优化
从查询上优化
从索引上优化
从存储上优化
</pre><ul><li>MySQL 客户端连接成功后，通过 show [session|global] status 命令可以查看服务器状态信息。</li><li>通过查看状态信息可以查看对当前数据库的主要操作类型。</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1289" mdtype="fences">当前 session 中所有统计参数的值
SHOW SESSION STATUS LIKE 'Com_______';  -- 查看当前会话统计结果
SHOW GLOBAL STATUS LIKE 'Com_______';  -- 查看自数据库上次启动至今统计结果
SHOW STATUS LIKE 'Innodb_rows_%';       -- 查看针对Innodb引擎的统计结果
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1290" mdtype="fences">Com_select					执行SELECT操作的次数，一次查询只累加一次
Com_insert					执行INSERT操作的次数，
Com_update					执行UPDATE操作的次数
Com_delete					执行DELETE操作的次数
Innodb_rows_read			SELECT查询返回的行数
Innodb_rows_inserted		执行INSERT操作插入的行数
Innodb_rows_updated			执行UODATE操作更新的行数
Innodb_rows_deleted			执行DELETE操作删除的行数
Connections					试图链接MySQL服务器的次数
Uptime						服务器工作时间
Slow_queries				慢查询的次数
</pre><p>&nbsp;</p><ul><li><p>可以通过以下两种方式定位执行效率较低的 SQL 语句：</p><ol start='' ><li>慢查询日志 : 通过慢查询日志定位那些执行效率较低的 SQL 语句。</li></ol></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1298" mdtype="fences">-- 查看慢日志配置信息 
SHOW VARIABLES LIKE '%slow_query_log%'; 

-- 开启慢日志查询 
SET GLOBAL slow_query_log=1; 

-- 查看慢日志记录SQL的最低阈值时间 
SHOW VARIABLES LIKE '%long_query_time%'; 

-- 修改慢日志记录SQL的最低阈值时间 
SET GLOBAL long_query_time=4;
</pre><ol start='2' ><li>定位低效率执行SQL：SHOW PROCESSLIST;</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1302" mdtype="fences">show processlist
该命令查看当前MySQL在进行的线程，包括线程的状态、是否锁表等，
可以实时地查看 SQL 的执行情况，同时对一些锁表操作进行优化。
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1303" mdtype="fences">1） id列，用户登录mysql时，系统分配的"connection_id"，可以使用函数connection_id()查看。
2） user列，显示当前用户。如果不是root，这个命令就只显示用户权限范围的sql语句。
3） host列，显示这个语句是从哪个ip的哪个端口上发的，可以用来跟踪出现问题语句的用户。
4） db列，显示这个进程目前连接的是哪个数据库。
5） command列，显示当前连接的执行的命令，一般取值为休眠（sleep），查询（query），连接（connect）等。
6） time列，显示这个状态持续的时间，单位是秒。
7） state列，显示使用当前连接的sql语句的状态，很重要的列。state描述的是语句执行中的某一个状态。一个sql语句，以查询为例，可能需要经过copying to tmp table、sorting result、sending data等状态才可以完成。
8） info列，显示这个sql语句，是判断问题语句的一个重要依据。
</pre><ul><li>查询到效率低的 SQL 语句后，可以通过 EXPLAIN命令获取 MySQL如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1307" mdtype="fences">EXPLAIN SELECT * FROM dept WHERE deptno = 1;
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1308" mdtype="fences">id				select查询的序列号，是一组数字，表示的是查询中执行select子句或者是操作表的顺序
select_type		表示SELECT的类型，常见的取值有SIMPLE(简单表，即不使用表连接或者子查询)、PRIMARY(主查询，即外层的查询)、UNION(UNION中的第二个或者后面的查询语句)、SUBQUERY(子查询中的第一个SELECT)等
table			输出结果集的表
type			表示表的连接类型，性能由好到差的连接类型为system--&gt;const--&gt;eq_ref--&gt;ref--&gt;ref_or_null--&gt;index_merge--&gt;index_subquery--&gt;range--&gt;index--&gt;all
possible_keys	表示查询时可能使用的索引
key				表示实际使用的索引
key_len			索引字段的长度
rows			扫描行的数量
extra			执行情况的说明和描述
</pre><ul><li>id：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1312" mdtype="fences"> id 字段是 select查询的序列号，是一组数字，表示的是查询中执行select子句或者是操作表的顺序。
 id 情况有三种:
	1、id 相同表示加载表的顺序是从上到下。
	2、id 不同id值越大，优先级越高，越先被执行。 
	3、id 有相同，也有不同，同时存在。id相同的可以认为是一组，从上往下顺序执行；
	在所有的组中，id的值越大，优先级越高，越先执行。
</pre><ul><li>select_type：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1316" mdtype="fences">SIMPLE		简单的select查询，查询中不包含子查询或者UNION
PRIMARY		查询中若包含任何复杂的子查询，最外层查询标记为该标识
SUBQUERY	在select或where列表中包含了子查询
DERIVED		在FROM列表中包含的子查询，被标记为DERIVED(衍生)MYSQL会递归执行这些子查询，把结果放在临时表中
UNION		若第二个SELECT出现在UNION之后，则标记为UNION；若UNION包含在FROM子句的子查询中，外层SELECT将被标记为DERIVED
UNIONRESULT	从UNION表获取结果的SELECT
</pre><ul><li>type：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1320" mdtype="fences">NULL		MYSQL不访问任何表，索引，直接返回结果
system		系统表，少量数据，往往不需要进行磁盘IO；如果是5.7及以上版本的话就不是system了，
			而是all，即使只有一条记录
const		命中主键(primary key)或者唯一(unique)索引，被连接的部分是一个常量(const)值
eq_ref		对于前表的每一行，后表只有一行被扫描。(1) join查询；
			(2) 命中主键(primary key)或者非空唯一(unique not null)索引；(3) 等值连接
ref			非唯一性索引扫描，返回匹配某个单独值的所有行。对于前表的每一行(row)，
			后表可能有多于一行的数据被扫描
range		只检索给定返回的行，使用一个索引来选择行。where之后出现between，&lt;，&gt;，in等操作
index		需要扫描索引上的全部数据
all			全表扫描，此时id上无索引

结果值从最好到最坏以此是：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; all
</pre><ul><li><p>table：显示这一步所访问数据库中表名称有时不是真实的表名字，可能是简称。</p></li><li><p>rows：扫描行的数量。</p></li><li><p>key：</p><ol start='' ><li>possible_keys : 显示可能应用在这张表的索引， 一个或多个。 </li><li>key ： 实际使用的索引， 如果为NULL， 则没有使用索引。</li><li>key_len : 表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下， 长度越短越好 。 </li></ol></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1335" mdtype="fences">id int							key_len = 4 + 1 = 5			允许NULL，加1-byte
id int not null					key_len = 4					不允许NULL
user char(30) utf8				key_len = 30 * 3 + 1		允许NULL
user varchar(30) not null utf8	key_len = 30 * 3 + 2		动态列类型，加2-bytes
user varchar(30) utf8			key_len = 30 * 3 + 2 + 1	动态列类型，加2-bytes；允许NULL，再加1-byte
detail text(10) utf8			key_len = 30 * 3 + 2 + 1	TEXT列截取部分，被视为动态列类型，加2-bytes；且允许NULL
</pre><ul><li>extra：其他的额外的执行计划信息，在该列展示 。</li><li>extra：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1341" mdtype="fences">using filesort		说明mysql会对数据使用一个	外部的索引排序，
					而不是按照表内的索引顺序进行读取，称为'文件排序'，效率低。
using temporarily	需要建立临时表(temporary table)来暂存中间结果，常见于order by和group by；效率低。
using index			SQL所需要返回的所有列数据均在一颗索引树上，避免访问表的数据行，效率不错。
</pre><ul><li>show profile分析SQL：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1345" mdtype="fences">-- 通过 have_profiling 参数，能够看到当前MySQL是否支持profile：
SELECT @@have_profiling; 
SET profiling=1; -- 开启profiling 开关； 
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1346" mdtype="fences">-- 查看sql语句执行耗时
SHOW PROFILES;
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1347" mdtype="fences">-- 通过show  profile for  query  query_id 语句可以查看到该SQL执行过程中每个线程的状态和消耗的时间：
SHOW PROFILE FOR QUERY 77;
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1348" mdtype="fences">-- 在获取到最消耗时间的线程状态后，
-- MySQL支持进一步选择all、cpu、block io 、context switch、page faults等明细类型
-- 查看MySQL在使用什么资源上耗费了过高的时间。

-- 选择查看CPU的耗费时间  ：
SHOW PROFILE cpu FOR QUERY 77;  
</pre><ul><li>字段含义：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1352" mdtype="fences">Status		sql语句执行的状态
Duration		sql执行过程中每一个步骤的耗时
CPU_user		当前用户占有的cpu
CPU_system	系统占有的cpu
</pre><ul><li>trace分析优化器执行计划：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1356" mdtype="fences">MySQL5.6提供了对SQL的跟踪trace, 通过trace文件能够进一步了解为什么优化器选择A计划, 而不是选择B计划
打开trace ， 设置格式为 JSON，并设置trace最大能够使用的内存大小，避免解析过程中因为默认内存过小而不能够完整展示。

SET optimizer_trace="enabled=on",end_markers_in_json=ON; 
SET optimizer_trace_max_mem_size=1000000;
-- 执行SQL语句 ：
SELECT * FROM USER WHERE uid &lt; 2;
-- 检查information_schema.optimizer_trace就可以知道MySQL是如何执行SQL的 ：
SELECT * FROM information_schema.optimizer_trace \G;
</pre><hr /><ul><li>索引优化：索引是数据库优化最常用也是最重要的手段之一, 通过索引通常可以帮助用户解决大多数的MySQL的性能优化问题。</li><li>导入数据：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1363" mdtype="fences" style="break-inside: unset;">当使用load 命令导入数据的时候，适当的设置可以提高导入的效率。
对于 InnoDB 类型的表，有以下几种方式可以提高导入的效率：

1 )、主键顺序插入
因为InnoDB类型的表是按照主键的顺序保存的，所以将导入的数据按照主键的顺序排列，可以有效的提高导入数据的效率。
如果InnoDB表没有主键，那么系统会自动默认创建一个内部列作为主键，所以如果可以给表创建一个主键，将可以利用这点，来提高导入数据的效率。

	1、首先，检查一个全局系统变量 'local_infile' 的状态， 如果得到如下显示 Value=OFF，则说明这是不可用的
	SHOW GLOBAL VARIABLES LIKE 'local_infile';
 
	2、修改local_infile值为on，开启local_infile
	SET GLOBAL local_infile=1;
 
	3、加载数据 
		脚本文件介绍 :
			sql1.log  ----&gt; 主键有序 22s
			sql2.log  ----&gt; 主键无序 81s
		LOAD DATA LOCAL INFILE 'D:\\sql_data\\sql1.log' INTO TABLE tb_user FIELDS TERMINATED BY ',' LINES TERMINATED BY '\n';
		LOAD DATA LOCAL INFILE 'D:\\sql_data\\sql2.log' INTO TABLE tb_user FIELDS TERMINATED BY ',' LINES TERMINATED BY '\n';

2 )、关闭唯一性校验
在导入数据前执行 SET UNIQUE_CHECKS=0，关闭唯一性校验，在导入结束后执行SET UNIQUE_CHECKS=1，
恢复唯一性校验，可以提高导入的效率。
	
	-- 关闭唯一性校验
	SET UNIQUE_CHECKS=0;
</pre><ul><li>优化insert语句：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1367" mdtype="fences">当进行数据的insert操作的时候，可以考虑采用以下几种优化方案:

	1.如果需要同时对一张表插入很多行数据时，应该尽量使用多个值表的insert语句，
这种方式将大大的缩减客户端与数据库之间的连接、关闭等消耗。使得效率比分开执行的单个insert语句快。

	2.在事务中进行数据插入。

	3.数据有序插入。
</pre><ul><li>优化order by语句：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1371" mdtype="fences" style="break-inside: unset;">-- 数据准备

CREATE TABLE emp (
  id INT(11) NOT NULL AUTO_INCREMENT,
  NAME VARCHAR(100) NOT NULL,
  age INT(3) NOT NULL,
  salary INT(11) DEFAULT NULL,
  PRIMARY KEY (id)
);
 
INSERT INTO emp (id, NAME, age, salary) VALUES('1','Tom','25','2300');
INSERT INTO emp (id, NAME, age, salary) VALUES('2','Jerry','30','3500');
INSERT INTO emp (id, NAME, age, salary) VALUES('3','Luci','25','2800');
INSERT INTO emp (id, NAME, age, salary) VALUES('4','Jay','36','3500');
INSERT INTO emp (id, NAME, age, salary) VALUES('5','Tom2','21','2200');
INSERT INTO emp (id, NAME, age, salary) VALUES('6','Jerry2','31','3300');
INSERT INTO emp (id, NAME, age, salary) VALUES('7','Luci2','26','2700');
INSERT INTO emp (id, NAME, age, salary) VALUES('8','Jay2','33','3500');
INSERT INTO emp (id, NAME, age, salary) VALUES('9','Tom3','23','2400');
INSERT INTO emp (id, NAME, age, salary) VALUES('10','Jerry3','32','3100');
INSERT INTO emp (id, NAME, age, salary) VALUES('11','Luci3','26','2900');
INSERT INTO emp (id, NAME, age, salary) VALUES('12','Jay3','37','4500');
 
CREATE INDEX idx_emp_age_salary ON emp(age,salary);

-- 排序 order by
EXPLAIN SELECT * FROM emp ORDER BY age;-- using filesort
EXPLAIN SELECT * FROM emp ORDER BY age,salary;-- using filesort
EXPLAIN SELECT id FROM emp ORDER BY age;-- using index
EXPLAIN SELECT id,age FROM emp ORDER BY age;-- using index
EXPLAIN SELECT id,age,salary FROM emp ORDER BY age;-- using filesort

-- order by 后面的多个排序字段要求尽量排序方式相同
EXPLAIN SELECT id,age FROM emp ORDER BY age ASC,salary DESC;-- using index;using filesort
EXPLAIN SELECT id,age FROM emp ORDER BY ag DESC,salary DESC;-- backward index scan;using index

-- order by 后面的多个排序字段尽量和组合索引字段顺序一致
EXPLAIN SELECT id,age FROM emp ORDER BY salary,age;-- using index;using filesort

两种排序方式：
	第一种是通过对返回数据进行排序，也就是通常说的 filesort 排序，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。
	第二种通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高。
</pre><ul><li>Filesort优化：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1375" mdtype="fences" style="break-inside: unset;">通过创建合适的索引，能够减少 Filesort 的出现，但是在某些情况下，
条件限制不能让Filesort消失，那就需要加快 Filesort的排序操作。
对于Filesort ， MySQL 有两种排序算法：
	
	1） 两次扫描算法 ：MySQL4.1 之前，使用该方式排序。首先根据条件取出排序字段和行指针信息，
	然后在排序区 sort buffer 中排序，如果sort buffer不够，则在临时表 temporary table 中存储排序结果。
	完成排序之后，再根据行指针回表读取记录，该操作可能会导致大量随机I/O操作。
	
	2）一次扫描算法：一次性取出满足条件的所有字段，然后在排序区 sort  buffer 中排序后直接输出结果集。
	排序时内存开销较大，但是排序效率比两次扫描算法要高。

	MySQL 通过比较系统变量 max_length_for_sort_data 的大小和Query语句取出的字段总大小， 	
	来判定是否那种排序算法，
	如果max_length_for_sort_data 更大，那么使用第二种优化之后的算法；否则使用第一种。
	可以适当提高 sort_buffer_size  和 max_length_for_sort_data  系统变量，
	来增大排序区的大小，提高排序的效率。

	SHOW VARIABLES LIKE 'max_length_for_sort_data';-- 4096
	SHOW VARIABLES LIKE 'sort_buffer_size';-- 262144
</pre><ul><li>优化group by：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1379" mdtype="fences">ORDER BY 相比，GROUP BY 主要只是多了排序之后的分组操作。
如果在分组的时候还使用了其他的一些聚合函数，那么还需要一些聚合函数的计算。
所以，在GROUP BY 的实现过程中，与 ORDER BY 一样也可以利用到索引。

如果查询包含 group by 但是用户想要避免排序结果的消耗， 则可以执行order by null 禁止排序。
DROP INDEX idx_emp_age_salary ON emp; 
EXPLAIN SELECT age,COUNT(*) FROM emp GROUP BY age;
EXPLAIN SELECT age,COUNT(*) FROM emp GROUP BY age ORDER BY NULL;
CREATE INDEX idx_emp_age_salary ON emp(age,salary);
</pre><ul><li>优化子查询：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1383" mdtype="fences">优化子查询
使用子查询可以一次性的完成很多逻辑上需要多个步骤才能完成的SQL操作，
同时也可以避免事务或者表锁死，并且写起来也很容易。
但是，有些情况下，子查询是可以被更高效的连接（JOIN）替代。

EXPLAIN SELECT * FROM USER WHERE uid IN (SELECT uid FROM user_role ); 
EXPLAIN SELECT * FROM USER u , user_role ur WHERE u.uid = ur.uid;
system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;ALL
连接(Join)查询之所以更有效率一些 ，
因为MySQL不需要在内存中创建临时表来完成这个逻辑上需要两个步骤的查询工作。
</pre><ul><li>优化limit查询：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1387" mdtype="fences" style="break-inside: unset;">优化limit查询
	一般分页查询时，通过创建覆盖索引能够比较好地提高性能。
	一个常见又非常头疼的问题就是 limit 900000,10  ，此时需要MySQL排序前900010 记录，
	仅仅返回900000 - 900010 的记录，其他记录丢弃，查询排序的代价非常大 。

	1、优化思路一：
	在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容。
	select count(*) from tb_user;
	select * from tb_user limit 0,10;
	select * from tb_user limit 900000,10;-- 0.684
	select * from tb_user a,(select id from tb_user order by id limit 900000,10) b where a.id = b.id;-- 0.486

	2、优化思路二（适用于主键自增的表，可以把Limit 查询转换成某个位置的查询。）
	select * from tb_user where id &gt; 900000 limit 10;
</pre><hr /><p><code>修改日期：2022-6-23 14:26:03</code></p></div>
</body>
</html>